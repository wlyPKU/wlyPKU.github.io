<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="baidu-site-verification" content="SjzK8OEtoc" />
<meta name="google-site-verification" content="bA1EerR_bNYAYfaP2nkHs-XeqIviTDWTI96YeW_6IkU" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Job Interview," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Anything about the interview preparing.">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview Prepare">
<meta property="og:url" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/index.html">
<meta property="og:site_name" content="小小小宇">
<meta property="og:description" content="Anything about the interview preparing.">
<meta property="og:image" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/elf.png">
<meta property="og:image" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/currency.jpg">
<meta property="og:image" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/JVM_1.jpg">
<meta property="og:image" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/JVM_2.jpg">
<meta property="og:image" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/JVM_3.jpg">
<meta property="og:image" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/JVM_HEAP_1.jpg">
<meta property="og:image" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/JVM_4.jpg">
<meta property="og:updated_time" content="2017-04-02T07:47:17.818Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Interview Prepare">
<meta name="twitter:description" content="Anything about the interview preparing.">
<meta name="twitter:image" content="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/elf.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://wlyPKU.github.io/2017/03/29/Interview-Prepare/"/>

  <title> Interview Prepare | 小小小宇 </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">小小小宇</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-leetcode">
          <a href="/categories/LeetCode" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Leetcode
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Interview Prepare
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-29T20:51:13+08:00" content="2017-03-29">
              2017-03-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Job-Interview/" itemprop="url" rel="index">
                    <span itemprop="name">Job Interview</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/29/Interview-Prepare/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/29/Interview-Prepare/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Anything about the interview preparing.<br><a id="more"></a></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>要了解二者的区别与联系，首先得对进程与线程有一个宏观上的了解。</p>
<p>  <strong>进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。进程空间的大小 只与处理机的位数有关，一个 16 位长处理机的进程空间大小为$2^{16}$，而 32 位处理机的进程空间大小为 $2^{32}$ 。进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。</strong></p>
<p>  <strong>线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。</strong></p>
<p>  说到这里，我们对进程与线程都有了一个大体上的印象，现在开始说说二者大致的区别。</p>
<p>  <strong>进程的执行过程是线状的</strong>，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。这是进程宏观上的执行过程。而进程又可有单线程进程与多线程进程两种。我们知道，进程有 一个进程控制块 PCB ，相关程序段 和 该程序段对其进行操作的数据结构集 这三部分，单线程进程的执行过程在宏观上是线性的，微观上也只有单一的执行过程；而多线程进程在宏观上的执行过程同样为线性的，但微观上却可以有多个执行操作（线程），如不同代码片段以及相关的数据结构集。<strong>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。出了 CPU 之外，计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</strong>与进程控制表和 PCB 相似，每个线程也有自己的线程控制表 TCB ，而这个 TCB 中所保存的线程状态信息则要比 PCB 表少得多，这些信息主要是相关指针用堆栈（系统栈和用户栈），寄存器中的状态数据。<strong>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</strong></p>
<p>  线程可以有效地提高系统的执行效率，但并不是在所有计算机系统中都是适用的，如某些很少做进程调度和切换的实时系统。使用线程的好处是有多个任务需要处理机处理时，减少处理机的切换时间；而且，线程的创建和结束所需要的系统开销也比进程的创建和结束要小得多。最适用使用线程的系统是多处理机系统和网络系统或分布式系统。</p>
<ol>
<li><p>线程的执行特性。<br> 线程只有 3 个基本状态：就绪，执行，阻塞。<br> 线程存在 5 种基本操作来切换线程的状态：派生，阻塞，激活，调度，结束。</p>
</li>
<li><p>进程通信。<br> 单机系统中进程通信有 4 种形式：主从式，会话式，消息或邮箱机制，共享存储区方式。<br> 主从式典型例子：终端控制进程和终端进程。<br> 会话式典型例子：用户进程与磁盘管理进程之间的通信。</p>
</li>
</ol>
<p>同一进程间的线程究竟共享哪些资源呢，而又各自独享哪些资源呢？<br>共享的资源有</p>
<ol>
<li><strong>堆</strong>  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）</li>
<li><strong>全局变量</strong> 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的</li>
<li><strong>静态变量</strong> 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的</li>
<li><strong>文件等公用资源</strong>  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体</li>
</ol>
<p>独享的资源有</p>
<ol>
<li><strong>栈</strong> 栈是独享的</li>
<li><strong>寄存器</strong>  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC</li>
</ol>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><p><a href="http://blog.csdn.net/edisonlg/article/details/7081357" target="_blank" rel="external">C++编译链接过程</a></p>
<hr>
<h2 id="ELF结构"><a href="#ELF结构" class="headerlink" title="ELF结构"></a>ELF结构</h2><img src="/2017/03/29/Interview-Prepare/elf.png" alt="ELF结构" title="ELF结构">
<p><a href="http://www.itcast.cn/news/20151228/16592094239.shtml?zx" target="_blank" rel="external">C++培训之Linux系统典型文件格式ELF</a></p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="final-static-const"><a href="#final-static-const" class="headerlink" title="final static const"></a>final static const</h2><p><strong>final</strong></p>
<ul>
<li>final修饰类：该类不可继承</li>
<li>final修饰方法：该方法不能被子类覆盖（但它不能修饰构造函数）</li>
<li>final修饰字段属性：属性值第一次初始化后不能被修改</li>
<li>使用final可以提高程序执行的效率，将一个方法设成final后编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。</li>
</ul>
<p><strong>static</strong></p>
<ul>
<li>static修饰成员函数则该函数不能使用this对象</li>
<li>static不能修饰构造函数、函数参数、局部成员变量</li>
<li>static修饰成员字段则当类被虚拟机加载时按照声明先后顺序对static成员字段进行初始化。</li>
<li>static修饰语句块：当类被虚拟机加载时按照声明先后顺序初始化static成员字段和static语句块</li>
<li>static所修饰的方法和字段只属于类，所有对象共享，java不能直接定义全局变量，是通过static来实现的。</li>
</ul>
<p>java中没有const，不能直接定义常量，是通过static final组合来实现的。</p>
<hr>
<h2 id="并行容器与同步容器"><a href="#并行容器与同步容器" class="headerlink" title="并行容器与同步容器"></a>并行容器与同步容器</h2><h3 id="简述同步容器与并发容器"><a href="#简述同步容器与并发容器" class="headerlink" title="简述同步容器与并发容器"></a>简述同步容器与并发容器</h3><p>在Java并发编程中，经常听到同步容器、并发容器之说，那什么是同步容器与并发容器呢？<strong>同步容器可以简单地理解为通过synchronized来实现同步的容器，比如Vector、Hashtable以及SynchronizedList等容器，如果有多个线程调用同步容器的方法，它们将会串行执行。</strong><br>而<strong>并发容器(线程安全的容器)则要满足线程安全的类无需调用方进行额外的同步</strong>。<br>可以通过查看Vector、Hashtable等同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized，但在某些情况下，同步容器不一定就是线程安全的，比如获取最后一个元素或者删除最后一个元素，我们需要实现额外的同步操作：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector <span class="built_in">list</span>)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> lastIndex = <span class="built_in">list</span>.size() - <span class="number">1</span>;  </div><div class="line">    <span class="keyword">return</span> <span class="built_in">list</span>.get(lastIndex);  </div><div class="line">&#125;  </div><div class="line">      </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector <span class="built_in">list</span>)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> lastIndex = <span class="built_in">list</span>.size() - <span class="number">1</span>;  </div><div class="line">    <span class="built_in">list</span>.remove(lastIndex);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然上面的方法看起来没有问题，Vector自身的方法也是同步的，但是在多线程环境中还是隐藏着问题。如果有两个线程A,B同时调用上面的两个方法，假设list的大小为10，这里计算得到的lastIndex为9，线程B首先执行了删除操作（多线程之间操作执行的不确定性导致），而后线程A调用了list.get方法，这时就会发生数组越界异常，导致问题的原因就是上面的复合操作不是原子操作，这里可以通过在方法内部使用list对象锁来实现原子操作。<br>同步容器会导致多个线程中对容器方法调用的串行执行，降低并发性，因为它们都是以容器自身对象为锁，所以在需要支持并发的环境中，可以考虑使用并发容器来替代。并发容器是针对多个线程并发访问而设计的，在jdk5.0引入了concurrent包，其中提供了很多并发容器，如ConcurrentHashMap、CopyOnWriteArrayList等。<br>其实同步容器与并发容器都为多线程并发访问提供了合适的线程安全，不过并发容器的可扩展性更高。在Java5之前，程序员们只有同步容器，且在多线程并发访问的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发容器，并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如，在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量，另外，并发容器提供了一些在使用同步容器时需要自己实现的复合操作，包括putIfAbsent等，但是由于并发容器不能通过加锁来独占访问，所以我们无法通过加锁来实现其他复合操作了。</p>
<h3 id="高效的映像、集合和队列"><a href="#高效的映像、集合和队列" class="headerlink" title="高效的映像、集合和队列"></a>高效的映像、集合和队列</h3><p>Java.util.concurrent包提供了映像、有序集和队列的高效实现： ConcurrentHashMap、ConcurrentSkipListMap、 ConcurrentSkipListSet和ConcurrentLinkedQueue。这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。与大多数集合不同， size方法不必在常量时间内操作。确定这样的集合当前的大小通常需要遍历。<br>集合返回弱一致性的迭代器。这意味着迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会被同一值返回两次，也不会抛出ConcurrentModificationException异常。</p>
<h3 id="写数组的拷贝"><a href="#写数组的拷贝" class="headerlink" title="写数组的拷贝"></a>写数组的拷贝</h3><p>CopyOnWriteArrayList和CopyOnWriteArraySet是线程安全的集合，其中所有的修改线程对底层数组进行复制。如果在集合上进行迭代的线程数超过修改线程数，这样的安排是很有用的。当构建一个迭代器的时候，它包含一个对当前数组的引用。如果数组后来被修改了，迭代器仍然引用旧数组，但是，集合的数组已经被替换了。因此，旧的迭代器拥有一致的试图，访问它无须任何同步开销。<br>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。<br>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<ul>
<li>内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。<br>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</li>
<li>数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li>
</ul>
<p>Ref:<a href="http://www.cnblogs.com/dolphin0520/p/3938914.html" target="_blank" rel="external">Java并发编程：并发容器之CopyOnWriteArrayList（转载）</a></p>
<h3 id="较早的线程安全集合"><a href="#较早的线程安全集合" class="headerlink" title="较早的线程安全集合"></a>较早的线程安全集合</h3><p>从Java的初始版本开始，Vector和Hashtable类就提供了线程安全的动态数组和散列表的实现。现在这些类被弃用了，取而代之的是ArrayList和HashMap类。这些类不是线程安全的，而集合库中提供了不同的机制。任何集合类通过使用同步包装器变成线程安全的：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">List</span>&lt;<span class="keyword">E</span>&gt; synchArrayList = Collections.synchronizedList(new ArrayList&lt;<span class="keyword">E</span>&gt;());  </div><div class="line"><span class="keyword">Map</span>&lt;<span class="keyword">K</span>,V&gt; synchHashMap = Collections.synchronizedMap(new HashMap&lt;<span class="keyword">K</span>,V&gt;());</div></pre></td></tr></table></figure></p>
<p>应该确保没有任何线程通过原始的非同步方法访问数据结构。最便利的方法是确保不保存任何指向原始对象的引用，简单地构造一个集合并立即传递给包装器。<br>如果在另一个线程可能进行修改时要对集合进行迭代，仍然需要使用“客户端”锁定：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">synchronized</span> (synchHashMap) &#123;  </div><div class="line">            <span class="keyword">Iterator&lt;K&gt; </span><span class="keyword">iter </span>= synchHashMap.keySet().<span class="keyword">iterator(); </span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>如果使用foreach循环必须使用同样代码，因为循环使用了迭代器。</strong></p>
<ul>
<li>同步的集合包装器 synchronizedMap 和 synchronizedList ，有时也被称作 有条件地线程安全――所有 单个的操作都是线程安全的，但是多个操作组成的操作序列却可能导致数据争用，因为在操作序列中控制流取决于前面操作的结果。 清单1中第一片段展示了公用的put-if-absent语句块――如果一个条目不在 Map 中，那么添加这个条目。不幸的是， 在 containsKey() 方法返回到 put() 方法被调用这段时间内，可能会有另一个线程也插入一个带有相同键的值。如果您想确保只有一次插入，您需要用一个对 Map m 进行同步的同步块将这一对语句包装起来。</li>
<li>集合框架引入了迭代器，用于遍历一个列表或者其他集合，从而优化了对一个集合中的元素进行迭代的过程。然而，在 java.util 集合类中实现的迭代器极易崩溃，也就是说，如果在一个线程正在通过一个 Iterator 遍历集合时，另一个线程也来修改这个 集合，那么接下来的 Iterator.hasNext() 或 Iterator.next() 调用将抛出 ConcurrentModificationException 异常。就拿 刚才这个例子来讲，如果想要防止出现 ConcurrentModificationException 异常，那么当您正在进行迭代时，您必须 使用一个在 List l 上同步的 synchronized 块将该 List 包装起来，从而锁住整个 List 。（或者，您也可以调用 List.toArray() ，在 不同步的情况下对数组进行迭代，但是如果列表比较大的话这样做代价很高）。</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>有如下几种”线程安全”的数据结构/包:</p>
<ol>
<li><strong>concurrent 包 set map queue</strong></li>
<li><strong>copyOnWriteArrayList copyOnWriteArraySet</strong></li>
<li><strong>vector hashTable</strong></li>
<li><strong>Collections.synchronizedList synchronizedMap</strong></li>
</ol>
<h4 id="vector与synchronizedList比较"><a href="#vector与synchronizedList比较" class="headerlink" title="vector与synchronizedList比较"></a>vector与synchronizedList比较</h4><p>Vector类中对get以及remove，size方法都加了synchronized关键字来保证同步，也就说当一个线程调用了这些方法时，其他线程不能再同时调用这些方法。换言之，<strong>不能出现两个及两个以上的线程在同时调用这些同步方法</strong>。 </p>
<p>区别就是Vector本身所有方法都是用synchronized修饰的，所以线程安全，而ArrayList没有<br>synchronizedList修饰的list包裹了普通的ArrayList提供了线程安全的机制，类似Vector，数据结构如下:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; TEST_LIST = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;());</div></pre></td></tr></table></figure></p>
<p>还有一个区别就是新增元素的时候Vector的增量是原来的一倍，而ArrayList增加原来的一半.</p>
<ol>
<li>到此为止synchronizedList与Vector的区别就是ArrayList与Vector的增量速度区别，所以需要线程安全操作时，增量比较快的时候推荐使用Vector.</li>
<li>SynchronizedList中实现的类并没有都使用synchronized同步代码块。其中有listIterator和listIterator(int index)并没有做同步处理。但是Vector却对该方法加了方法锁。 所以说，在使用SynchronizedList进行遍历的时候要手动加锁。</li>
<li>SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。</li>
</ol>
<p>Ref:<a href="http://www.cnblogs.com/yanghuahui/p/3365976.html" target="_blank" rel="external">ArrayList和Vector以及synchronizedList</a><br>Ref:<a href="http://www.hollischuang.com/archives/498" target="_blank" rel="external">SynchronizedList和Vector的区别</a></p>
<h4 id="Map的同步比较"><a href="#Map的同步比较" class="headerlink" title="Map的同步比较:"></a>Map的同步比较:</h4><p>Hashtable 的后继者 HashMap 是作为JDK1.2中的集合框架的一部分出现的，它通过提供一个不同步的基类和一个同步的包装器 Collections.synchronizedMap ，解决了线程安全性问题。 通过将基本的功能从线程安全性中分离开来， Collections.synchronizedMap 允许需要同步的用户可以拥有同步，而不需要同步的用户则不必为同步付出代价。<br>Hashtable 和 synchronizedMap 所采取的获得同步的简单方法（同步 Hashtable 中或者同步的 Map 包装器对象中的每个方法）有两个主要的不足。首先，这种方法对于可伸缩性是一种障碍，因为一次只能有一个线程可以访问hash表。 同时，这样仍不足以提供真正的线程安全性，许多公用的混合操作仍然需要额外的同步。虽然诸如 get() 和 put() 之类的简单操作可以在不需要额外同步的情况下安全地完成，但还是有一些公用的操作序列 ，例如迭代或者put-if-absent（空则放入），需要外部的同步，以避免数据争用。</p>
<p>concurrentHashMap的具体见:<a href="http://www.cnblogs.com/studyLog-share/p/5283646.html" target="_blank" rel="external">java并发：同步容器&amp;并发容器</a><br>HashTable与ConcurrentHashMap的比较？<br>相同点： Hashtable 和 ConcurrentHashMap都是线程安全的，可以在多线程环境中运行； key跟value都不能是null<br>区别： 两者主要是性能上的差异，Hashtable的所有操作都会锁住整个对象，虽然能够保证线程安全，但是性能较差； ConcurrentHashMap内部使用Segment数组，每个Segment类似于Hashtable，在“写”线程或者部分特殊的“读”线程中锁住的是某个Segment对象，其它的线程能够并发执行其它的Segment对象。</p>
<hr>
<h2 id="参数传递–值传递"><a href="#参数传递–值传递" class="headerlink" title="参数传递–值传递"></a>参数传递–值传递</h2><p>首先要说明的是java中是没有指针的，java中只存在值传递，只存在值传递！！！  然而我们经常看到对于对象（数组，类，接口）的传递似乎有点像引用传递，可以改变对象中某个属性的值。但是不要被这个假象所蒙蔽，实际上这个传入函数的值是对象引用的拷贝，即传递的是引用的地址值，所以还是按值传递。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test3</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span>(<span class="params"><span class="keyword">int</span> a</span>)</span>&#123;</div><div class="line">        a=<span class="number">50</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        <span class="keyword">int</span> a=<span class="number">10</span>;</div><div class="line">        System.<span class="keyword">out</span>.println(a);</div><div class="line">        change(a);</div><div class="line">        System.<span class="keyword">out</span>.println(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出 10 10</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test3</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span>(<span class="params"><span class="keyword">int</span> []a</span>)</span>&#123;</div><div class="line">        a[<span class="number">0</span>]=<span class="number">50</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        <span class="keyword">int</span> []a=&#123;<span class="number">10</span>,<span class="number">20</span>&#125;;</div><div class="line">        System.<span class="keyword">out</span>.println(a[<span class="number">0</span>]);</div><div class="line">        change(a);</div><div class="line">        System.<span class="keyword">out</span>.println(a[<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出10 50 实际传递的是引用的地址值。</p>
<hr>
<h2 id="大数处理"><a href="#大数处理" class="headerlink" title="大数处理"></a>大数处理</h2><p>在Java中有两个类BigInteger和BigDecimal分别表示大整数类和大浮点数类，至于两个类的对象能表示最大范围不清楚，理论上能够表示无线大的数，只要计算机内存足够大。<br>这两个类都在java.math.*包中，因此每次必须在开头处引用该包。<br>Ⅰ基本函数：<br>1.valueOf(parament); 将参数转换为制定的类型<br>   比如 int a=3;<br>       BigInteger b=BigInteger.valueOf(a);<br>     则b=3;<br>         String s=”12345”;<br>       BigInteger c=BigInteger.valueOf(s);<br>       则c=12345；</p>
<p>2.add(); 大整数相加<br>   BigInteger a=new BigInteger(“23”);<br>   BigInteger b=new BigInteger(“34”);<br>a.      add(b);</p>
<p>3.subtract(); 相减<br>4.multiply(); 相乘<br>5.divide();    相除取整<br>6.remainder(); 取余<br>7.pow();   a.pow(b)=a^b<br>8.gcd();   最大公约数<br>9.abs(); 绝对值<br>10.negate(); 取反数<br>11.mod(); a.mod(b)=a%b=a.remainder(b);<br>12.max(); min();<br>13.punlic int comareTo();<br>14.boolean equals(); 是否相等</p>
<hr>
<h2 id="extends-and-implements"><a href="#extends-and-implements" class="headerlink" title="extends and implements"></a>extends and implements</h2><p>接口实现的注意点：</p>
<ul>
<li>实现一个接口就是要实现该接口的所有的方法(抽象类除外)。</li>
<li>接口中的方法都是抽象的。</li>
<li>多个无关的类可以实现同一个接口，一个类可以实现多个无关的接口。</li>
</ul>
<p><strong>extends与implements的区别：</strong><br>extends 是继承父类，只要那个类不是声明为final或者那个类定义为abstract的就能继承，JAVA中不支持多重继承，但是可以用接口来实现，这样就用到了implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了。</p>
<p>比如：<br>class A extends B implements C,D,E {}    （class 子类名 extends 父类名 implenments 接口名）</p>
<p><strong>父类与子类继承关系上的不同：</strong></p>
<p>A a = new B(); 结果a是一个A类的实例，只能访问A中的方法，那么又和A a = new A();有什么区别呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></div><div class="line">继承过后通常会定义一些父类没有的成员或者方法。</div><div class="line"><span class="type">A</span> a = <span class="keyword">new</span> <span class="type">B</span>();</div><div class="line">这样是可以的，上传。</div><div class="line">a是一个父类对象的实例，因而不能访问子类定义的新成员或方法。</div></pre></td></tr></table></figure>
<p>假如这样定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">   int i;</div><div class="line">   void f()&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">    int j;</div><div class="line">    void f()&#123;&#125;       <span class="comment">//重写</span></div><div class="line">    void g()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后：<br>B b = new B();<br>b就是子类对象的实例，不仅能够访问自己的属性和方法，也能够访问父类的属性和方法。诸如b.i,b.j,b.f(),b.g()都是合法的。此时b.f()是访问的B中的f()</p>
<p>A a = new B();<br>a虽然是用的B的构造函数，但经过upcast，成为父类对象的实例，不能访问子类的属性和方法。a.i,a.f()是合法的，而a.j,a.g()非法。此时访问a.f()是访问B中的f()</p>
<p>A a = new B(); 这条语句，实际上有三个过程：<br>(1) A a;<br>将a声明为父类对象，只是一个引用，未分配空间<br>(2) B temp = new B();<br>通过B类的构造函数建立了一个B类对象的实例，也就是初始化<br>(3) a = (A)temp;<br>将子类对象temp转换未父类对象并赋给a，这就是上传(upcast)，是安全的。<br>经过以上3个过程，a就彻底成为了一个A类的实例。<br>子类往往比父类有更多的属性和方法，上传只是舍弃，是安全的；而下传(downcast)有时会增加，通常是不安全的。</p>
<p>a.f()对应的应该是B类的方法f()<br>调用构造函数建立实例过后，对应方法的入口已经确定了。<br>如此以来，a虽被上传为A类，但其中重写的方法f()仍然是B的方法f()。也就是说，每个对象知道自己应该调用哪个方法。<br>A a1 = new B();<br>A a2 = new C();<br>a1,a2两个虽然都是A类对象，但各自的f()不同。这正是多态性的体现。</p>
<hr>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>public char charAt(int index)<br>返回字符串中第index个字符；<br>public int length()<br>返回字符串的长度；<br>public int indexOf(String str)<br>返回字符串中第一次出现str的位置；<br>public int indexOf(String str,int fromIndex)<br>返回字符串从fromIndex开始第一次出现str的位置；<br>public boolean equalsIgnoreCase(String another)<br>比较字符串与another是否一样（忽略大小写）；<br>public String replace(char oldchar,char newChar)<br>在字符串中用newChar字符替换oldChar字符<br>public boolean startsWith(String prefix)<br>判断字符串是否以prefix字符串开头；<br>public boolean endsWith(String suffix)<br>判断一个字符串是否以suffix字符串结尾；<br>public String toUpperCase()<br>返回一个字符串为该字符串的大写形式；<br>public String toLowerCase()<br>返回一个字符串为该字符串的小写形式<br>public String substring(int beginIndex)<br>返回该字符串从beginIndex开始到结尾的子字符串；<br>public String substring(int beginIndex,int endIndex)<br>返回该字符串从beginIndex开始到endsIndex结尾的子字符串<br>public String trim()<br>返回该字符串去掉开头和结尾空格后的字符串<br>public String[] split(String regex)<br>将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组</p>
<hr>
<h2 id="string-stringBuffer-stringBuilder"><a href="#string-stringBuffer-stringBuilder" class="headerlink" title="string, stringBuffer, stringBuilder"></a>string, stringBuffer, stringBuilder</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String：字符串常量，字符串长度不可变。Java中String是immutable（不可变）的。<br>String类的包含如下定义：<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** The value is used for character storage. */</span>  </div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </div><div class="line">  </div><div class="line"><span class="comment">/** The offset is the first index of the storage that is used. */</span>  </div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;  </div><div class="line">  </div><div class="line"><span class="comment">/** The count is the number of characters in the String. */</span>  </div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</div></pre></td></tr></table></figure></p>
<p>用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。</p>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p>StringBuffer：<strong>字符串变量（Synchronized，即线程安全）</strong>。如果要频繁对字符串内容进行修改，出于效率考虑最好使用StringBuffer，如果想转成String类型，可以调用StringBuffer的toString()方法。<br>Java.lang.StringBuffer线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。<br>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p>
<h3 id="StringBuilder（JDK5-0）"><a href="#StringBuilder（JDK5-0）" class="headerlink" title="StringBuilder（JDK5.0）"></a>StringBuilder（JDK5.0）</h3><p>StringBuilder：字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。<br>java.lang.StringBuilder是一个可变的字符序列，是JDK5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。<br>其构造方法如下：</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>StringBuilder()</td>
<td>创建一个容量为16的StringBuilder对象（16个空元素）</td>
</tr>
<tr>
<td>StringBuilder(CharSequence cs)</td>
<td>创建一个包含cs的StringBuilder对象，末尾附加16个空元素</td>
</tr>
<tr>
<td>StringBuilder(int initCapacity)</td>
<td>创建一个容量为initCapacity的StringBuilder对象</td>
</tr>
<tr>
<td>StringBuilder(String s)</td>
<td>创建一个包含s的StringBuilder对象，末尾附加16个空元素</td>
</tr>
</tbody>
</table>
<p>在大部分情况下，StringBuilder &gt; StringBuffer。这主要是由于前者不需要考虑线程安全。</p>
<h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><p><strong>String 类型和StringBuffer的主要性能区别：String是不可变的对象, 因此在每次对String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。</strong><br>使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。</p>
<h3 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h3><ul>
<li>基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。</li>
<li>不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则。</li>
<li>为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过 16 个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能。</li>
<li>StringBuilder一般使用在方法内部来完成类似”+”功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer主要用在全局变量中。</li>
<li>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用StringBuilder；否则还是用StringBuffer。</li>
</ul>
<p>Ref: <a href="http://blog.csdn.net/kingzone_2008/article/details/9220691" target="_blank" rel="external">Java：String、StringBuffer和StringBuilder的区别</a></p>
<hr>
<h2 id="JVM线程安全"><a href="#JVM线程安全" class="headerlink" title="JVM线程安全"></a>JVM线程安全</h2><h3 id="synchronized详解"><a href="#synchronized详解" class="headerlink" title="synchronized详解"></a>synchronized详解</h3><p>Ref: <a href="http://www.cnblogs.com/GnagWang/archive/2011/02/27/1966606.html" target="_blank" rel="external">java synchronized详解</a></p>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>jvm运行时刻内存的分配。其中有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。下面一幅图描述这写交互<br><img src="/2017/03/29/Interview-Prepare/currency.jpg" alt="内存示意" title="内存示意"><br>read and load 从主存复制变量到当前工作内存<br>use and assign  执行代码，改变共享变量值<br>store and write 用工作内存数据刷新主存相关内容</p>
<p>其中use and assign 可以多次出现。<br>Ref: <a href="http://blog.csdn.net/libing13820393394/article/details/48582999" target="_blank" rel="external">volatile解析</a></p>
<hr>
<h2 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h2><p>java代码具体执行过程如下图<br><img src="/2017/03/29/Interview-Prepare/JVM_1.jpg" alt="JVM" title="JVM"></p>
<p>运行时数据区，即jvm内存结构图如下图<br><img src="/2017/03/29/Interview-Prepare/JVM_2.jpg" alt="JVM" title="JVM"></p>
<p>Java运行时数据区结构<br><strong>a) 程序计数器(PC寄存器)</strong></p>
<p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切 换 之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，</p>
<p>因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p>
<p><strong>b) java栈</strong></p>
<p>Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括<strong>局部变量表(Local Variables) 、 操作数栈(Operand Stack) 、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到） 的引用 (Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息</strong>。</p>
<p>当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。<br><img src="/2017/03/29/Interview-Prepare/JVM_3.jpg" alt="JVM" title="JVM"></p>
<p><strong>c）本地方法栈</strong></p>
<p>本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的.<br>本地方法调用的三种需求</p>
<ol>
<li>代码在其他语言上进行了大量的测试</li>
<li>对效率要求比较高,如Math.exp(),Math.log()</li>
<li>与系统或硬件交互,如System.out()</li>
</ol>
<p><strong>d）堆</strong></p>
<p>Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。</p>
<p>Java 6中的堆结构是这样的：<br><img src="/2017/03/29/Interview-Prepare/JVM_HEAP_1.jpg" alt="JVM" title="JVM"></p>
<h3 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h3><p>持久代中包含了虚拟机中所有可通过反射获取到的数据，比如Class和Method对象。不同的Java虚拟机之间可能会进行类共享，因此持久代又分为只读区和读写区。</p>
<p>JVM用于描述应用程序中用到的类和方法的元数据也存储在持久代中。JVM运行时会用到多少持久代的空间取决于应用程序用到了多少类。除此之外，Java SE库中的类和方法也都存储在这里。</p>
<p>如果JVM发现有的类已经不再需要了，它会去回收（卸载）这些类，将它们的空间释放出来给其它类使用。Full GC会进行持久代的回收。</p>
<ul>
<li>JVM中类的元数据在Java堆中的存储区域。</li>
<li>Java类对应的HotSpot虚拟机中的内部表示也存储在这里。</li>
<li>类的层级信息，字段，名字。</li>
<li>方法的编译信息及字节码。</li>
<li>变量</li>
<li>常量池和符号解析</li>
</ul>
<p><strong>为什么移除持久代</strong></p>
<ul>
<li>它的大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？</li>
<li>HotSpot的内部类型也是Java对象：它可能会在Full GC中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。</li>
<li>简化Full GC：每一个回收器有专门的元数据迭代器。</li>
<li>可以在GC不进行暂停的情况下并发地释放类数据。</li>
<li>使得原来受限于持久代的一些改进未来有可能实现</li>
</ul>
<h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>持久代的空间被彻底地删除了，它被一个叫元空间的区域所替代了。持久代删除了之后，很明显，JVM会忽略PermSize和MaxPermSize这两个参数，还有就是你再也看不到java.lang.OutOfMemoryError: PermGen error的异常了。</p>
<p>JDK 8的HotSpot JVM现在使用的是本地内存来表示类的元数据，这个区域就叫做元空间。</p>
<p><strong>元空间的特点：</strong></p>
<ul>
<li>充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。</li>
<li>每个加载器有专门的存储空间</li>
<li>只进行线性分配</li>
<li>不会单独回收某个类</li>
<li>省掉了GC扫描及压缩的时间</li>
<li>元空间里的对象的位置是固定的</li>
<li>如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉</li>
</ul>
<p><strong>元空间的内存分配模型</strong></p>
<ul>
<li>绝大多数的类元数据的空间都从本地内存中分配</li>
<li>用来描述类元数据的类也被删除了</li>
<li>分元数据分配了多个虚拟内存空间</li>
<li>给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些</li>
<li>归还内存块，释放内存块列表</li>
<li>一旦元空间的数据被清空了，虚拟内存的空间会被回收掉</li>
<li>减少碎片的策略</li>
</ul>
<p><strong>e）方法区</strong></p>
<p>与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。<br>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。<br>在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，<br>对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</p>
<h3 id="JVM内存溢出的情况"><a href="#JVM内存溢出的情况" class="headerlink" title="JVM内存溢出的情况"></a>JVM内存溢出的情况</h3><img src="/2017/03/29/Interview-Prepare/JVM_4.jpg" alt="JVM" title="JVM">
<p>Ref: <a href="http://www.cnblogs.com/dingyingsi/p/3760447.html" target="_blank" rel="external">深入理解JVM—JVM内存模型</a><br>Ref: <a href="http://www.tuicool.com/articles/bmQjyiR" target="_blank" rel="external">jvm内存模型和内存分配</a></p>
<hr>
<h2 id="Java内存回收"><a href="#Java内存回收" class="headerlink" title="Java内存回收"></a>Java内存回收</h2><p>虚拟机中的共划分为三个代：年轻代（Young Generation）、老年代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。    </p>
<p><strong>年轻代</strong><br>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p>
<p><strong>年老代</strong><br>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p><strong>持久代</strong>(Not supported in Java 8)<br>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<n>进行设置。</n></p>
<p><strong>Scavenge GC</strong><br>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
<p><strong>Full GC</strong><br>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>
<ul>
<li>年老代（Tenured）被写满</li>
<li>持久代（Perm）被写满</li>
<li>System.gc()被显示调用</li>
<li>上一次GC之后Heap的各域分配策略动态变化</li>
</ul>
<hr>
<h2 id="Java反射机制详解"><a href="#Java反射机制详解" class="headerlink" title="Java反射机制详解"></a>Java反射机制详解</h2><h3 id="反射机制是什么"><a href="#反射机制是什么" class="headerlink" title="反射机制是什么"></a>反射机制是什么</h3><p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<h3 id="反射机制能做什么"><a href="#反射机制能做什么" class="headerlink" title="反射机制能做什么"></a>反射机制能做什么</h3><p>反射机制主要提供了以下功能： </p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成动态代理。</li>
</ul>
<hr>
<h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p><strong>为什么要用线程池:</strong></p>
<ol>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<p><strong>关键变量</strong><br>创建一个线程池需要输入几个参数：</p>
<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</li>
<li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>
</ul>
</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a><strong>newCachedThreadPool()</strong></h4><p>创建一个可缓存的线程池，即这个线程池是无界线程池，无界指工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger.MAX_VALUE),这样可以灵活的往线程池中添加数据；可以进行自动线程回收指的是如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p>
<h4 id="newFixedThreadPool-int"><a href="#newFixedThreadPool-int" class="headerlink" title="newFixedThreadPool(int)"></a>newFixedThreadPool(int)</h4><p>固定大小线程池这个很好理解，就是创建一个指定工作线程数量的线程池，如果线程达到设置的最大数，就将提交的任务放到线程池的队列中。一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h4><p>  单线程线程池，只创建唯一的线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行。</p>
<h4 id="newScheduledThreadPool-int-corePoolSize"><a href="#newScheduledThreadPool-int-corePoolSize" class="headerlink" title="newScheduledThreadPool(int corePoolSize)"></a>newScheduledThreadPool(int corePoolSize)</h4><p>线程池能按时间计划来执行任务，允许用户设定计划执行任务的时间。参数corePoolSize设定线程池中线程的最小数目。当任务较多时，线程池可能会创建更多的工作线程来执行任务</p>
<p>newCachedThreadPool的参数为SynchronousQueue，newFixedThreadPool和newSingleThreadExecutor的参数都为LinkedBlockingQueue.</p>
<h4 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h4><p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>
<ol>
<li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li>
<li>任务的优先级：高，中和低。</li>
<li>任务的执行时间：长，中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ol>
<p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>
<p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<p>Ref:<a href="https://www.oschina.net/question/565065_86540" target="_blank" rel="external">Java线程池使用说明</a><br>Ref:<a href="http://blog.csdn.net/scboyhj__/article/details/48805881" target="_blank" rel="external">【Java高级】ThreadPool用法与优势</a></p>
<hr>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Job-Interview/" rel="tag">#Job Interview</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/20/IntroductionToPCA/" rel="next" title="主成份分析算法 PCA">
                <i class="fa fa-chevron-left"></i> 主成份分析算法 PCA
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/29/Class-imbalance-in-classification/" rel="prev" title="Class imbalance in classification">
                Class imbalance in classification <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ww3.sinaimg.cn/mw690/770b0925jw8f39az302pwj20w00w0dnd.jpg"
               alt="wlyPKU" />
          <p class="site-author-name" itemprop="name">wlyPKU</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wlyPKU" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/wangly2011/profile" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/wangly.cs" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Facebook
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程与进程"><span class="nav-number">1.1.</span> <span class="nav-text">线程与进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number">2.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译链接"><span class="nav-number">2.1.</span> <span class="nav-text">编译链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF结构"><span class="nav-number">2.2.</span> <span class="nav-text">ELF结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">3.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#final-static-const"><span class="nav-number">3.1.</span> <span class="nav-text">final static const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行容器与同步容器"><span class="nav-number">3.2.</span> <span class="nav-text">并行容器与同步容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简述同步容器与并发容器"><span class="nav-number">3.2.1.</span> <span class="nav-text">简述同步容器与并发容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高效的映像、集合和队列"><span class="nav-number">3.2.2.</span> <span class="nav-text">高效的映像、集合和队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写数组的拷贝"><span class="nav-number">3.2.3.</span> <span class="nav-text">写数组的拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#较早的线程安全集合"><span class="nav-number">3.2.4.</span> <span class="nav-text">较早的线程安全集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较"><span class="nav-number">3.2.5.</span> <span class="nav-text">比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vector与synchronizedList比较"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">vector与synchronizedList比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map的同步比较"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">Map的同步比较:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数传递–值传递"><span class="nav-number">3.3.</span> <span class="nav-text">参数传递–值传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大数处理"><span class="nav-number">3.4.</span> <span class="nav-text">大数处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extends-and-implements"><span class="nav-number">3.5.</span> <span class="nav-text">extends and implements</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string"><span class="nav-number">3.6.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string-stringBuffer-stringBuilder"><span class="nav-number">3.7.</span> <span class="nav-text">string, stringBuffer, stringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">3.7.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer"><span class="nav-number">3.7.2.</span> <span class="nav-text">StringBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder（JDK5-0）"><span class="nav-number">3.7.3.</span> <span class="nav-text">StringBuilder（JDK5.0）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三者区别"><span class="nav-number">3.7.4.</span> <span class="nav-text">三者区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用策略"><span class="nav-number">3.7.5.</span> <span class="nav-text">使用策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM线程安全"><span class="nav-number">3.8.</span> <span class="nav-text">JVM线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized详解"><span class="nav-number">3.8.1.</span> <span class="nav-text">synchronized详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile关键字"><span class="nav-number">3.8.2.</span> <span class="nav-text">volatile关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM内存"><span class="nav-number">3.9.</span> <span class="nav-text">JVM内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#持久代"><span class="nav-number">3.9.1.</span> <span class="nav-text">持久代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元空间"><span class="nav-number">3.9.2.</span> <span class="nav-text">元空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM内存溢出的情况"><span class="nav-number">3.9.3.</span> <span class="nav-text">JVM内存溢出的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存回收"><span class="nav-number">3.10.</span> <span class="nav-text">Java内存回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java反射机制详解"><span class="nav-number">3.11.</span> <span class="nav-text">Java反射机制详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#反射机制是什么"><span class="nav-number">3.11.1.</span> <span class="nav-text">反射机制是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射机制能做什么"><span class="nav-number">3.11.2.</span> <span class="nav-text">反射机制能做什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPool"><span class="nav-number">3.12.</span> <span class="nav-text">ThreadPool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">3.12.0.1.</span> <span class="nav-text">newCachedThreadPool()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newFixedThreadPool-int"><span class="nav-number">3.12.0.2.</span> <span class="nav-text">newFixedThreadPool(int)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-number">3.12.0.3.</span> <span class="nav-text">newSingleThreadExecutor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newScheduledThreadPool-int-corePoolSize"><span class="nav-number">3.12.0.4.</span> <span class="nav-text">newScheduledThreadPool(int corePoolSize)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合理的配置线程池"><span class="nav-number">3.12.0.5.</span> <span class="nav-text">合理的配置线程池</span></a></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wlyPKU</span>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'wlypku';
      var disqus_identifier = '2017/03/29/Interview-Prepare/';
      var disqus_title = "Interview Prepare";
      var disqus_url = 'http://wlyPKU.github.io/2017/03/29/Interview-Prepare/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


</body>
</html>
