<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Parallel SGD]]></title>
      <url>http://wlyPKU.github.io/2016/10/07/Parallel-SGD/</url>
      <content type="html"><![CDATA[<p>Parallelizing and distributing SGD</p>
<ul>
<li>Parallelized Stochastic Gradient Descent</li>
<li>Hogwild!</li>
<li>Downpour SGD<a id="more"></a>
<h1 id="Parallelized-Stochastic-Gradient-Descent"><a href="#Parallelized-Stochastic-Gradient-Descent" class="headerlink" title="Parallelized Stochastic Gradient Descent"></a>Parallelized Stochastic Gradient Descent</h1></li>
<li><a href="http://www.research.rutgers.edu/~lihong/pub/Zinkevich11Parallelized.pdf" target="_blank" rel="external">Parallelized Stochastic Gradient Descent</a></li>
</ul>
<p>算法步骤:</p>
<ol>
<li>将训练数据集$D$负载均衡地划分为$c$个子集: $D=\bigcup_{i=1}^{c}D_i$,其中$\left|D_1\right|=\left|D_2\right|=\left|D_3\right|=…=\left|D_c\right|=T$,并将子集$D_i$分配到第i台机器.</li>
<li>在每台机器上，给定学习率$\eta$,并令向量$v:=0$.</li>
<li>对于$i\in\left\{ 1,2,…,c \right\} $,<strong>并行地</strong>执行:<ol>
<li>将$D_i$中的元素随机打乱,设得到的样本序列为$ \left\{  \tilde{x}_j , \tilde{y}_j \right\}^T_{j=1}$</li>
<li>初始化$w_0^{(i)}:=v$.</li>
<li>按照以下循环更新参数.<br><strong>FOR </strong> $j = 1,2,…,T$  <strong>DO</strong><br>{<br>$\quad\quad w_j^{(i)} = w_{j-1}^{(i)}-\eta\left. \frac{\partial l(x_i, y_i,w)}{\partial w}\right|_{(\tilde{x}_j , \tilde{y}_j , {w_{j-1}^{(i)}})}$<br>}</li>
</ol>
</li>
<li>通过<strong>全归约</strong>操作,使每台机器获得<strong>平均</strong>权值向量$v=\frac{1}{c} \sum_{k=1}^c w_T^{(i)}$</li>
<li>若达到收敛准则,则算法结束,返回$v$;否则,转至3.</li>
</ol>
<p>算法只涉及<strong>数据并行</strong>,没有<strong>模型并行</strong>(每台机器上都有一份完整的模型参数$w$),因此它适合于模型参数量相对较小,而训练数据集相对较大的情形.每台机器各自负责一个本地数据块的计算,计算完成后,执行一次通信(step 4),获取更新后的值.<br><img src="/2016/10/07/Parallel-SGD/psgd.png" alt="算法示意" title="算法示意"><br><img src="/2016/10/07/Parallel-SGD/psgd1.png" alt="实验示意" title="实验示意"></p>
<h1 id="Hogwild"><a href="#Hogwild" class="headerlink" title="Hogwild!"></a>Hogwild!</h1><ul>
<li><a href="https://people.eecs.berkeley.edu/~brecht/papers/hogwildTR.pdf" target="_blank" rel="external">Hogwild!: A Lock-Free Approach to Parallelizing Stochastic Gradient Descent</a></li>
</ul>
<p>Niu提出了被称为Hogwild的并行SGD方法。该方法在多个CPU时间进行并行。处理器通过共享内存来访问参数，并且这些参数不进行加锁。它为每一个cpu分配不重叠的一部分参数（分配互斥），每个cpu只更新其负责的参数。该方法只适合处理数据特征是稀疏的。该方法几乎可以达到一个最优的收敛速度，因为cpu之间不会进行相同信息重写。<br><img src="/2016/10/07/Parallel-SGD/hogwild!.png" alt="算法示意" title="算法示意"><br><img src="/2016/10/07/Parallel-SGD/hogwild!1.png" alt="实验示意" title="实验示意"></p>
<h1 id="Downpour-SGD"><a href="#Downpour-SGD" class="headerlink" title="Downpour SGD"></a>Downpour SGD</h1><ul>
<li><a href="http://doi.org/10.1109/ICDAR.2011.95" target="_blank" rel="external">Large Scale Distributed Deep Networks</a></li>
</ul>
<p>Downpour SGD 是 Dean et al. 4在 Google 的 DistBelief 框架中使用的一个异步 SGD 的变种（TensorFlow 的前身）。它在训练数据的子集上并行运行多个模型的复制。它们会把自己的更新发送到一个参数服务器上，而完整的参数被分发到许多的机器上。每个机器负责一小部分的模型参数的存储和更新。然而，因为各个复制模型直接并没有通信，即分享权重或者更新，它们的参数会持续遇到发散、妨碍收敛的问题。<br>请见:<a href="https://wlypku.github.io/2016/10/06/Downpour-SGD/">Downpour SGD</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SGD 变种]]></title>
      <url>http://wlyPKU.github.io/2016/10/06/SGD-variants/</url>
      <content type="html"><![CDATA[<p>A brief introduction to stochastic gradient descent and its variants.<br><a id="more"></a></p>
<h1 id="SGD模型"><a href="#SGD模型" class="headerlink" title="SGD模型"></a>SGD模型</h1><p>SGD指stochastic gradient descent, 即随机梯度下降,是梯度下降的batch版本.<br>对于训练数据集，我们首先将其分成n个batch，每个batch包含m个样本。我们每次更新都利用一个batch的数据，而非整个训练集。即：<br>\begin{equation}<br>\theta = \theta - \eta \cdot \nabla_\theta J( \theta; x^{(i)}; y^{(i)})<br>\end{equation}<br>其中, $\eta$ 为学习率，$g_t$为$x$在$t$时刻的梯度。<br>这么做的好处在于：</p>
<ol>
<li>当训练数据太多时，利用整个数据集更新往往时间上不显示。batch的方法可以减少机器的压力，并且可以更快地收敛。</li>
<li>当训练集有很多冗余时（类似的样本出现多次），batch方法收敛更快。以一个极端情况为例，若训练集前一半和后一半梯度相同。那么如果前一半作为一个batch，后一半作为另一个batch，那么在一次遍历训练集时，batch的方法向最优解前进两个step，而整体的方法只前进一个step。</li>
</ol>
<h1 id="非自适应算法"><a href="#非自适应算法" class="headerlink" title="非自适应算法"></a>非自适应算法</h1><h2 id="动量SGD"><a href="#动量SGD" class="headerlink" title="动量SGD"></a>动量SGD</h2><p>SGD方法的一个缺点是，其更新方向完全依赖于当前的batch，因而其更新十分不稳定。解决这一问题的一个简单的做法便是引入momentum。<br>momentum即动量，它模拟的是物体运动时的惯性，即更新的时候在一定程度上保留之前更新的方向，同时利用当前batch的梯度微调最终的更新方向。这样一来，可以在一定程度上增加稳定性，从而学习地更快，并且还有一定摆脱局部最优的能力：<br>\begin{equation}<br>v_t = \gamma v_{t-1} + \eta \nabla_\theta J( \theta)<br>\end{equation}<br>\begin{equation}<br>\theta = \theta - v_t<br>\end{equation}<br>其中，$\gamma$即momentum，表示要在多大程度上保留原来的更新方向，这个值在0-1之间，在训练开始时，由于梯度可能会很大，所以初始值一般选为0.5；当梯度不那么大时，改为0.9。$\eta$是学习率，即当前batch的梯度多大程度上影响最终更新方向，跟普通的SGD含义相同。$\gamma$ 与 $\eta$ 之和不一定为1。</p>
<div align="center"><br><img src="/2016/10/06/SGD-variants/without_momentum.jpg" alt="标准SGD" title="标准SGD"><br><img src="/2016/10/06/SGD-variants/with_momentum.jpg" alt="动量SGD" title="动量SGD"><br></div>

<p>SGD has trouble navigating ravines, i.e. areas where the surface curves much more steeply in one dimension than in another, which are common around local optima. In these scenarios, SGD oscillates across the slopes of the ravine while only making hesitant progress along the bottom towards the local optimum as in Image 1.<br>Momentum is a method that helps accelerate SGD in the relevant direction and dampens oscillations as can be seen in Image 2. It does this by adding a fraction γ of the update vector of the past time step to the current update vector:<br>\begin{equation}<br>v_t = \gamma v_{t-1} + \eta \nabla_\theta J( \theta)<br>\end{equation}<br>\begin{equation}<br>\theta = \theta - v_t<br>\end{equation}<br>Some implementations exchange the signs in the equations. The momentum term γ is usually set to 0.9 or a similar value.When cross-validated, this parameter is usually set to values such as [0.5, 0.9, 0.95, 0.99]. Similar to annealing schedules for learning rates (discussed later, below), optimization can sometimes benefit a little from momentum schedules, where the momentum is increased in later stages of learning. A typical setting is to start with momentum of about 0.5 and anneal it to 0.99 or so over multiple epochs.<br>Essentially, when using momentum, we push a ball down a hill. The ball accumulates momentum as it rolls downhill, becoming faster and faster on the way (until it reaches its terminal velocity if there is air resistance, i.e. γ&lt;1).<br>The same thing happens to our parameter updates: The momentum term increases for dimensions whose gradients point in the same directions and reduces updates for dimensions whose gradients change directions. As a result, we gain faster convergence and reduced oscillation.</p>
<h2 id="Nesterov-Momentum"><a href="#Nesterov-Momentum" class="headerlink" title="Nesterov Momentum"></a>Nesterov Momentum</h2><p>这是对传统momentum方法的一项改进，由Ilya Sutskever(2012 unpublished)在Nesterov工作的启发下提出的。<br>其基本思路如下图（转自Hinton的coursera公开课lecture 6a）:</p>
<div align="center"><br><img src="/2016/10/06/SGD-variants/nesterov.jpeg" alt="nesterov动量" title="nesterov动量"><br><img src="/2016/10/06/SGD-variants/Nesterov_Momentum.jpg" alt="nesterov动量" title="nesterov动量"><br></div>

<p>首先，按照原来的更新方向更新一步（棕色线），然后在该位置计算梯度值（红色线），然后用这个梯度值修正最终的更新方向（绿色线）。上图中描述了两步的更新示意图，其中蓝色线是标准momentum更新路径。</p>
<p>公式描述为：<br>\begin{equation}<br>v_t = \gamma v_{t-1} + \eta \nabla_\theta J( \theta - \gamma v_{t-1} )<br>\end{equation}<br>\begin{equation}<br>\theta = \theta - v_t<br>\end{equation}<br>However, a ball that rolls down a hill, blindly following the slope, is highly unsatisfactory. We’d like to have a smarter ball, a ball that has a notion of where it is going so that it knows to slow down before the hill slopes up again.\\<br>Nesterov accelerated gradient (NAG) is a way to give our momentum term this kind of prescience. We know that we will use our momentum term γvt−1 to move the parameters θ. Computing $\theta−\gamma v_t−1$ thus gives us an approximation of the next position of the parameters (the gradient is missing for the full update), a rough idea where our parameters are going to be. We can now effectively look ahead by calculating the gradient not w.r.t. to our current parameters θθ but w.r.t. the approximate future position of our parameters:<br>Like momentum,NAG is a first-order optimization method with better convergence rate guarantee than gradient descent in certain situations. In particular, for general smooth(non-strongly) convex functions and a deterministic gradient, NAG achieves a global convergence rate of O($1/T^2$) (versus the O(1/T) of gradient descent), with constant proportional to the Lipschitz coefficient of the derivative and the squared Euclidean distance to the solution. While NAG is not typically thought of as a type of momentum, it indeed turns out to be closely related to classical momentum, differing only in the precise update of the velocity vector v.</p>
<h2 id="learing-rate-选择"><a href="#learing-rate-选择" class="headerlink" title="learing rate 选择"></a>learing rate 选择</h2><h3 id="常数learning-rate"><a href="#常数learning-rate" class="headerlink" title="常数learning rate"></a>常数learning rate</h3><h3 id="折半下降"><a href="#折半下降" class="headerlink" title="折半下降"></a>折半下降</h3><p>每若干轮降低下learning rate,如每5轮降低一半,或者每20轮降低0.1<br>Reduce the learning rate by some factor every few epochs. Typical values might be reducing the learning rate by a half every 5 epochs, or by 0.1 every 20 epochs. These numbers depend heavily on the type of problem and the model. One heuristic you may see in practice is to watch the validation error while training with a fixed learning rate, and reduce the learning rate by a constant (e.g. 0.5) whenever the validation error stops improving. \par</p>
<h3 id="指数下降"><a href="#指数下降" class="headerlink" title="指数下降"></a>指数下降</h3><p>\begin{equation}<br>\alpha = \frac{\alpha_0}{e^{kt}}<br>\end{equation}<br>其中是$k$超参数,$t$是迭代轮数</p>
<h3 id="frac-1-t-下降"><a href="#frac-1-t-下降" class="headerlink" title="$\frac{1}{t}$下降"></a>$\frac{1}{t}$下降</h3><p>\begin{equation}<br>\alpha = \frac{\alpha_0}{1+kt}<br>\end{equation}<br>数学形式,$k$是超参数,$t$是迭代轮数。</p>
<h1 id="自适应算法"><a href="#自适应算法" class="headerlink" title="自适应算法"></a>自适应算法</h1><h2 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h2><p>上面提到的方法对于所有参数都使用了同一个更新速率。但是同一个更新速率不一定适合所有参数。比如有的参数可能已经到了仅需要微调的阶段，但又有些参数由于对应样本少等原因，还需要较大幅度的调动。<br>Adagrad就是针对这一问题提出的，自适应地为各个参数分配不同学习率的算法。其公式如下：<br>\begin{equation}<br>\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{G_{t} + \epsilon}} \odot g_{t}<br>\end{equation}<br>其中$G^{t}\in R^{d\times d}$是一个对角矩阵，其中<br>\begin{equation}<br>G_{i, i} = \sqrt{\sum_{T=1}^tg_{T,i}^2}<br>\end{equation}<br>而$\epsilon$是一个平滑系数，使得不会出现除零的现象，通常在$10^{-8}$量级。Adagrad的一个主要优势是考虑了不同参数可能处在更新的不同阶段，同时避免了调参的问题，通常可以取 $\eta$为0.01.<br>Adagrad的一个主要缺点在于其参数的平方和累加：因为随着训练轮数的增加，每一个累加项都是正数，这使得整体的学习速率最终会变得非常的小,最终模型会静止不动(可能尚未到达收敛点).</p>
<h2 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h2><p>Adagrad算法存在三个问题<br>1.其学习率是单调递减的，训练后期学习率非常小<br>2.其需要手工设置一个全局的初始学习率<br>3.更新时，左右两边的单位不同一<br>Adadelta针对上述三个问题提出了比较漂亮的解决方案。其公式如下：<br>\begin{equation}<br>E[g^2]_t = \gamma E[g^2]_{t-1} + (1 - \gamma) g^2_t<br>\end{equation}<br>\begin{equation}<br>E[\Delta \theta^2]_t = \gamma E[\Delta \theta^2]_{t-1} + (1 - \gamma) \Delta \theta^2_t<br>\end{equation}<br>\begin{equation}<br>RMS[\Delta \theta]_{t} = \sqrt{E[\Delta \theta^2]_t + \epsilon}\end{equation}<br>\begin{equation}<br>\Delta \theta_t = - \dfrac{RMS[\Delta \theta]_{t-1}}{RMS[g]_{t}} g_{t}<br>\end{equation}<br>\begin{equation}<br>\theta_{t+1} = \theta_t + \Delta \theta_t<br>\end{equation}<br>$\gamma$的值近似在0.9左右，同时$\epsilon$是一个平滑系数，使得不会出现除零的现象，通常在$10^{-8}$量级.<br>可以看到，如此一来adagrad中分子部分需要人工设置的初始学习率也消失了。</p>
<p>Experiment: neural network MINIST$ ADADELTA &gt; ADAGRAD &gt; MOMENTUM &gt; SGD$</p>
<div align="center"><br><img src="/2016/10/06/SGD-variants/adadelta.jpg" alt="实验比较" title="实验比较"><br></div>

<h2 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h2><p>RMSprop是一个未出版的，自适应学习速率方法，由Geoff Hinton提出。RMSprop和Adadelta的提出都源自于Adagrad，目的是为了解决Adagrad学习速率在迭代若干次后彻底消失的问题。本质上而言，其与Adadelta相同。<br>\begin{equation}<br>E[g^2]_t = 0.9 E[g^2]_{t-1} + 0.1 g^2_t<br>\end{equation}<br>\begin{equation}<br>\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{E[g^2]_t + \epsilon}} g_{t}<br>\end{equation}<br>Hinton建议设置$\epsilon$为0.9，而$\eta$的学习速率为0.001.</p>
<h2 id="adam"><a href="#adam" class="headerlink" title="adam"></a>adam</h2><p>\begin{equation}<br>m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t<br>\end{equation}<br>\begin{equation}<br>v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2<br>\end{equation}<br>\begin{equation}<br>\hat{m}_t = \dfrac{m_t}{1 - \beta^t_1}<br>\end{equation}<br>\begin{equation}<br>\hat{v}_t = \dfrac{v_t}{1 - \beta^t_2}<br>\end{equation}<br>\begin{equation}<br>\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t<br>\end{equation}<br>该方法和RMSProp唯一的区别是smooth过程,这里使用的是m来做smooth操作,而不是使用原始的gradient vector. 论文中推荐的超参数为eps=1e-6, bata1=0.9, beta2=0.999, 在实践中, 如果没有其他的特殊理由,一般推荐使用Adam方法, 并且, Adam算法通常会比RMSProp算法效果好. 另外,也可以尝试SGD+Nesterov Momentum. 完整的Adam算法中还包括bias的纠正机制, 这事因为,在刚开始的几个steps中,m和v都要初始化, 并且在warm up 之前他们都biased at zero.<br>更多的细节可以参考论文原文.<br>论文:The method computes individual adaptive learning rates for different parameters from estimates of first and second moments of the gradients; the name Adam is derived from adaptive moment estimation. Our method is designed to combine the advantages of two recently popular methods: AdaGrad (Duchi et al., 2011), which works well with sparse gradients, and RMSProp (Tieleman &amp; Hinton, 2012), which works well in on-line and non-stationary settings; important connections to these and other stochastic optimization methods are clarified in section 5.Some of Adam’s advantages are that the magnitudes of parameter updates are invariant to rescaling of the gradient, its stepsizes are approximately bounded by the stepsize hyperparameter, it does not require a stationary objective, it works with sparse gradients, and it naturally performs a form of step size annealing.</p>
<h2 id="Adamax"><a href="#Adamax" class="headerlink" title="Adamax"></a>Adamax</h2><ul>
<li><a href="https://arxiv.org/pdf/1412.6980v8.pdf" target="_blank" rel="external">ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION</a><br>Adamax是Adam的一种变体，此方法对学习率的上限提供了一个更简单的范围。公式上的变化如下：<br>\begin{equation}<br>m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t<br>\end{equation}<br>\begin{equation}<br>v_t = max(\beta_2 \times v_{t-1}, \left| g_t\right|)<br>\end{equation}<br>\begin{equation}<br>\hat{m}_t = \dfrac{m_t}{1 - \beta^t_1}<br>\end{equation}<br>\begin{equation}<br>\theta_{t+1} = \theta_{t} - \dfrac{\eta}{v_t + \epsilon} \hat{m}_t<br>\end{equation}<br>可以看出，Adamax学习率的边界范围更简单.<br>parameter: Keras recommend:<br>Good default settings for the tested machine learning problems are $\eta= 0.002$, $\beta_1 = 0.9$ and $\beta_2= 0.999$. With $\beta_1^t$ we denote $\beta_1$ to the power $t$. Here, $\frac{\eta}{1-\beta_1^t}$is the learning rate with the bias-correction term for the first moment. <h2 id="Nadam"><a href="#Nadam" class="headerlink" title="Nadam"></a>Nadam</h2></li>
<li><a href="http://cs229.stanford.edu/proj2015/054_report.pdf" target="_blank" rel="external">Incorporating Nesterov Momentum into Adam</a></li>
</ul>
<p>Nadam类似于带有Nesterov动量项的Adam。公式如下：<br>\begin{equation}<br>\hat{g_t}=\frac{g_t}{1-\Pi_{i=1}^t\beta_{1i}}<br>\end{equation}<br>\begin{equation}<br>m_t=\beta_{1t} \times m_{t-1}+(1-\beta_{1t})\times g_t<br>\end{equation}<br>\begin{equation}<br>\hat{m_t}=\frac{m_t}{1-\Pi_{i=1}^{t+1}\beta_{1i}}<br>\end{equation}<br>\begin{equation}<br>n_t=\beta_2\times n_{t-1}+(1-\beta_2)\times g_t^2<br>\end{equation}<br>\begin{equation}<br>\bar{m_t}=(1-\beta_{1t})\times \hat{g_t}+\beta_{1(t+1)}\times \hat{m_t}<br>\end{equation}<br>\begin{equation}<br>\hat{n_t}=\frac{n_t}{1-\beta_{2}^t}<br>\end{equation}<br>\begin{equation}<br>\Delta{\theta_t}=-\eta*\frac{\bar{m_t}}{\sqrt{\hat{n_t}}+\epsilon}<br>\end{equation}<br>可以看出，Nadam对学习率有了更强的约束，同时对梯度的更新也有更直接的影响。一般而言，在想使用带动量的RMSprop，或者Adam的地方，大多可以使用Nadam取得更好的效果。</p>
<p>parameter: Keras recommend: lr=0.002, beta_1=0.9, beta_2=0.999, epsilon=1e-08, schedule_decay=0.004<br><strong>All algorithms used $\beta_2$ = .999and $\epsilon$ = 1e−8 as suggested, with a momentum schedule given by $\beta_{1t} = \beta_1\times (1−0.5\times 0.96^{\frac{t}{250}})$ with $\beta_1$ = .99</strong></p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>经验之谈</p>
<ul>
<li>对于稀疏数据，尽量使用学习率可自适应的优化方法，不用手动调节，而且最好采用默认值</li>
<li>SGD通常训练时间更长，但是在好的初始化和学习率调度方案的情况下，结果更可靠</li>
<li>如果在意更快的收敛，并且需要训练较深较复杂的网络时，推荐使用学习率自适应的优化方法。</li>
<li>Adadelta，RMSprop，Adam是比较相近的算法，在相似的情况下表现差不多。</li>
<li>在想使用带动量的RMSprop，或者Adam的地方，大多可以使用Nadam取得更好的效果</li>
</ul>
<img src="/2016/10/06/SGD-variants/contours_evaluation_optimizers.gif" alt="SGD optimization on loss surface contours" title="SGD optimization on loss surface contours">
<img src="/2016/10/06/SGD-variants/saddle_point_evaluation_optimizers.gif" alt="SGD optimization on saddle point" title="SGD optimization on saddle point">
<p>Experiment: </p>
<ul>
<li>MNIST Logistic regression<br>Adam&gt; Nesterov &gt; AdaGrad ( converage cost)</li>
<li>IMDB BoW feature logsitic regression<br> $ Adam \approx Adagrad \approx RMSProp \approx Nesterov$</li>
<li>deepLearning </li>
</ul>
<div align="center"><br><img src="/2016/10/06/SGD-variants/1.png" alt="实验结果1" title="实验结果1"><br><img src="/2016/10/06/SGD-variants/2.png" alt="实验结果2" title="实验结果2"><br><img src="/2016/10/06/SGD-variants/3.png" alt="实验结果3" title="实验结果3"><br></div>

<p>MINST: Adagrad/Adadelta并不需要设置学习速率，相对安全,但调好参数的SGD+动量表现也非常出色。<br>原文:This demo lets you evaluate multiple trainers against each other on MNIST. By default I’ve set up a little benchmark that puts SGD/SGD with momentum/Adagrad/Adadelta/Nesterov against each other. For reference math and explanations on these refer to Matthew Zeiler’s Adadelta paper (Windowgrad is Idea #1 in the paper). In my own experience, Adagrad/Adadelta are “safer” because they don’t depend so strongly on setting of learning rates (with Adadelta being slightly better), but well-tuned SGD+Momentum almost always converges faster and at better final values.</p>
<p><strong>参考</strong><br><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="external">http://sebastianruder.com/optimizing-gradient-descent/</a><br><a href="https://keras.io/optimizers/" target="_blank" rel="external">https://keras.io/optimizers/</a><br><a href="http://cs231n.github.io/neural-networks-3/#sgd" target="_blank" rel="external">http://cs231n.github.io/neural-networks-3/#sgd</a><br><a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" target="_blank" rel="external">https://en.wikipedia.org/wiki/Stochastic_gradient_descent</a><br><a href="http://blog.csdn.net/luo123n/article/details/48239963" target="_blank" rel="external">http://blog.csdn.net/luo123n/article/details/48239963</a><br><a href="http://blog.csdn.net/majordong100/article/details/51428642" target="_blank" rel="external">http://blog.csdn.net/majordong100/article/details/51428642</a><br><a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="external">http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf</a><br><a href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/trainers.html" target="_blank" rel="external">http://cs.stanford.edu/people/karpathy/convnetjs/demo/trainers.html</a><br><strong>Paper</strong><br>Unit Tests for Stochastic Optimization<br>ADADELTA: AN ADAPTIVE LEARNING RATE METHOD<br>ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION<br>Incorporating Nesterov Momentum into Adam</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Downpour SGD(大规模分布式深度网络)]]></title>
      <url>http://wlyPKU.github.io/2016/10/06/Downpour-SGD/</url>
      <content type="html"><![CDATA[<p>Parallel SGD Paper<br><a href="http://doi.org/10.1109/ICDAR.2011.95" target="_blank" rel="external"><strong>Large Scale Distributed Deep Networks</strong></a><br><a id="more"></a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>最近关于无监督特征学习（unsupervised feature learning）和深度学习（deep learning）的工作表明，具有训练大型模型能力的系统能够显著地提升深度神经网络的训练效果。在这篇文章中，我们针对的问题是利用多达10^4数量的CPU来训练一个具有10^9数量的参数（parameter）的深度网络。为了达到训练的目的，我们开发了称为DistBelief的软件框架，其利用具有上千节点（译者注：为了一致性，译文中的节点均指机器，即计算节点；而神经网络中的节点，均称为单元）的计算集群来训练大型模型。</p>
<p>在该框架中，实现了两个算法用于大规模分布训练：</p>
<ol>
<li>Downpour（译者注：猜测这里的Downpour主要是指并行地参数更新，就像倾盆大雨中，雨点从多处同时落下一样）SGD（stochastic gradient descent），一个支持大量模型副本的异步随机梯度下降过程。</li>
<li>Sandblaster（译者注：形容来自coordinator的命令像砂粒一样喷向集群其他节点），一个支持多种批量（batch）计算的分布优化方法，包含了L-BFGS的分布式实现，Downpour SGD和Sandblaster L-BFGS 都具有提升系统扩展能力和加速深度网络训练的能力。</li>
</ol>
<p>我们已经成功地利用DistBelief训练出一个比先前研究中提到的大30余倍的深度网络模型，并且获得了针对ImageNet（一个具有21K个分类和10M图像视觉识别任务）的最先进的训练效果。同时，我们还证明了，以上提及的技术能够显著地提升一个中等大小的，用作商用语音识别服务的深度网络的训练效果。尽管我们的这些技术主要用在大型神经网络的训练上，但是相关的算法同样适用于任何基于梯度的机器学习算法。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>深度学习和无监督特征学习给许多实际应用带了新的巨大希望。它在包括语音识别[1, 2]、视觉物体识别[3, 4]和文本处理[5, 6]等不同领域上体现了最领先的性能优势和效果。 先前研究已经证明，通过增加样本数量和模型参数数量等不同手段，可以显著地提升分类算法的最终精确度[3, 4, 7]。该结论掀起了研究可扩展的深度学习训练和推断算法和提高其适用性等优化方法的热潮[7, 9]。近年来，在中等大小深度网络的训练上，一个重要的进步是因GPU的使用，使其变得更加的实用[1, 2, 3, 8]。但GPU众所周知的缺陷是，当其内存（通常小于6G）无法存放下模型时，训练的提升效果变得不再明显。这时，为了有效地使用GPU，研究者往往通过减少样本或变量规模的途径使得CPU和GPU之间的数据交换不在成为瓶颈。虽然数据或变量的减少对小规模问题（如针对于声学模型的语音识别）有效，但对具有大量样本和高维度变量的问题（如高分辨率图像）将失去效果。<br>在本文中，我们提出了一个替代的方法，使用大规模的计算集群来分布地对深度网络进行训练和推断。我们开发了一个既能提升节点内（通过多线程方式）又可提升节点间（通过消息传递）并行训练能力的软件框架，称为DistBelief。它管理了如并行计算、同步化和通信等底层的细节。除了支持模型并行，DistBelief同时还支持数据并行，通过单一模型的多个分布副本的方式来优化同一目标。在该框架中，我们设计并实现了两个用于大规模分布式训练的新方法：i)Downpuur SGD，一个利用自适应学习速率和支持大量模型副本的异步随机梯度下降过程；(ii)Sandblaster L-BFGS，L-BFGS过程的一个分布式实现，其利用了数据和模型的并行（原作者注：我们利用Sandblaster方法实现了L-BFGS，但是Sandblaster同样广泛适用于其他批量方法的优化）。两个方法相比较于常规的SGD或L-BFGS方法都获得了显著的速度提升。 关于大规模非凸方法优化，我们的实验呈现了一些出人意料的结果。首先，异步梯度下降，一个很少被用到非凸问题的方法，尤其是与Adagrad[10]自适应学习速率结合时，用以训练深度网络的效果很好。其次，当计算资源充足时，L-BFGS方法能够和许多SGD的变种方法相匹敌，甚至优于后者。 对于深度学习的特定应用，我们提出了两项发现：前面提及的分布式优化方法，不仅可以加速中等规模模型的训练，同时它也可以训练规模大于想象的模型。为了证明第一点，我们利用分布式集群来训练中等大小语音识别模型，获得了与GPU相同的分类精度，而耗时仅是后者的1/10。为了证明第二点，我们训练了一个具有1G数量参数的大型神经网络，并用训练结果把ImageNet（计算机视觉领域最大的数据库之一）判别分类结果提升到了最先进的水平。</p>
<h1 id="前期工作"><a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h1><p>近年来，用于商业和学术的机器学习数据集呈空前增长的趋势。因此，一些研究者开始探索可扩展的机器学习算法来处理这些泛洪数据[11, 12, 13, 14, 15, 16, 17]。但大量的研究仍着眼于线性凸模型[11, 12, 17]。在凸模型中，分布式梯度计算自然是第一步，但是有时因为同步的问题会遭遇训练速度减慢。针对该问题，已经有一些有效果的工作，如异步随机梯度下降算法中的无锁参数更新（如Hogwild![19]）。不幸的是，将这些方法扩展到的非凸情况的研究，如处理训练深度网络中遇到的问题，还是一片未知的领域。特别地，在存在多个局部最小解的情况下，是否能够使用参数平均或者执行密集的异步参数更新方法，还是未知的问题。 在深度学习范畴中，大多数工作仍然集中在利用单节点训练较小规模模型（如Theano[20]）上。关于向上扩展深度学习的一些有意思的建议是，利用GPU来训练多个小型模型，然后将分别的预测结果取平均[21]，或者修改标准的深度网络使其能够从本质上并行化。而与这些前期工作不同，我们关注于扩展深度网络用于训练具有10^9参数数量的超大模型，同时避免给模型形式引入限制。在分布式扩展方面，模型的并行，其思想和[23]类似，是一个主要的组成部分，同时其也必须和巧妙的分布优化方法相结合以利用数据的并行性。 我们也考虑了用一些现有的大规模计算工具，如Mapreduce和GraphLab等来处理大规模深度学习。我们发现为数据并行处理而设计的Mapreduce，极其不适合深度网络训练中固有的迭代计算；而用于通用（通常是无结构的）图计算的GraphLab，同样没有利用模型并行深度网络中典型的分层图结构来提升计算效率。</p>
<h1 id="模型并行"><a href="#模型并行" class="headerlink" title="模型并行"></a>模型并行</h1><p>为了使超大规模深度网络的训练变得容易，我们开发了软件框架——DistBelief，用以支持神经网络的并行计算和分层图形模型。用户只需定义发生在每个单元上的计算过程以单元在向上传递和向下传递（原作者注：对于神经网络而言，“向上”和“向下”指的是“前馈”和“反向传播”，而对于隐式Markov模型，它们与“前向”和“后向”意思更相近）时需发送的消息。对于大型模型，用户可能会将模型加以划分（如图1所示），使得不同节点的计算任务被分配到了不同机器上。DistBelief自动地利用CPU资源将节点内计算并行化，同时它还管理了底层通信、同步化和在训练和推断时的机器间数据传输。 将深度网络分布到多个机器上所带来的性能提升主要取决于模型的连通结构和计算需求。具有大量参数或高计算需求的模型通过增加CPU和内存数量通常可以提升训练速度，直到增加到通信开销成为系统的瓶颈。我们已成功地在144个划分（机器）上运行DistBelief框架，且获得了显著的性能提升，同时在8或16个划分上运行的一个中等大小模型，也获得了很好的效果（请参考第5节中模型并行化基准测试中的实验结果）。显然地，局部连通的网络模型，因为需要更少的网络通信，所以比全连通网络模型更易于分布化。导致性能退化的一个主要原因是因不同机器上处理时间的不同，导致大量的机器在等待一个或单个节点完成本阶段任务（译者注：和MapReduce中Map阶段的长尾问题类似）。尽管如此，对于我们最大的模型来讲，我们仍可以高效地用总共有512核CPU 的32台机器（每台机器平均使用16核CPU的计算资源）来训练单个神经网络。当和下一节中讲到的利用模型多副本方法的分布式优化算法相结合时，将使得在多达10K的CPU数量上训练单个网络成为可能，从而进一步减少总的训练时间。</p>
<h1 id="分布式优化算法"><a href="#分布式优化算法" class="headerlink" title="分布式优化算法"></a>分布式优化算法</h1><p>DistBelief框架中的并行计算方法使我们能够部署和运行比前期工作中提到的大得多的神经网络模型。但是为了在合理时间内训练如此规模的模型，这就要求我们不仅需实现单个DistBelief实例内的并行，而且需要将训练任务分发到多个DistBelief实例。在本节中，我们将具体阐述这第二级的并行，即采用多个DistBelief模型的实例（或副本），同时来达到一个优化目标。<br><img src="/2016/10/06/Downpour-SGD/large_scale.png" alt="large_scale.png" title=""></p>
<ul>
<li>左：Downpour SGD，模型的副本采用异步方式从参数服务器（Parameter Server）中获取参数w和上传Δw到参数服务器。</li>
<li>右：Sandblaster L-BFGS：单个协调器（Coordinator）实例发送简短消息（message）到模型副本和参数服务器以协调批量优化过程。</li>
</ul>
<p>下面我们来对这两个分布优化方法做比较：Downpour SGD是在线方法，而L-BFGS是批量方法。两方法中模型副本都利用了中心分割化服务器组的概念来共享参数，也都利用了每个模型副本中DistBelief的并行性。但更重要的是，对不同副本的处理时间的不同，甚至整个模型副本的失效、移除和重启等情况都在两方法的考虑范围之内。</p>
<h2 id="Downpour-SGD"><a href="#Downpour-SGD" class="headerlink" title="Downpour SGD"></a>Downpour SGD</h2><p>随机梯度下降（SGD）方法，应该是最常用的训练深度神经网络的优化方法[26, 27, 3]。但不幸的是，传统SGD方法本质上的顺序性，使得在大型数据集下变得不再适用，因为这种完全串行方式所需要的机器间数据移动是非常耗时的。</p>
<p>为了将SGD应用到大数据集上，我们提出了Downpour SGD，一个使用单个DistBelief模型的多个分布副本的异步随机梯度下降变种。它的基本方法如下：将训练集划分若干子集，并对每个子集运行一个单独的模型副本。模型副本之间的通信均通过中心参数服务器组，该参数服务器组维护了模型参数的当前状态，并分割到多台机器上（例如，如果我们参数服务器组有10个节点，那么每个节点将负责存储和更新模型参数的1/10，如图1所示）。该方法在两个方面体现异步性：</p>
<ol>
<li>模型副本之间运行独立</li>
<li>参数服务器组各节点之间同样是独立的。</li>
</ol>
<p>考虑Downpour SGD的一个最简单的实现，在处理每个mini-batch（译者注：小型批量）之前，模型副本都会向参数服务器请求最新的模型参数。因为DistBelief框架也是分布在多台机器上，所以其框架的每个节点只需和参数服务器组中包含和该节点有关的模型参数的那部分节点进行通信。在DistBelief副本获得更新后的模型参数后，运行一次mini-batch样本来计算参数的梯度，并推送到参数服务器，以用于更新当前的模型参数值。<br>可以通过设定每Nfetch 次mini-batch操作向参数服务器获取一次更新后的参数和每npush次mini-batch操作推送一次梯度更新到参数服务器（这里nfetch不一定和npush相等）。事实上，获取参数，推送梯度和处理训练样本三种操作，可以以三个采用弱同步的线程实现（参见附录中的伪代码）。为了简单起见，同时也是为了和传统SGD方法相比较，在下面的实验中，我们设定: Nfetch=Npush=1<br>在处理机器失效方面，Downpour SGD比标准（同步）SGD要鲁棒。对于同步SGD来讲，如果一台机器失效，整个训练过程将会延时；但是对于异步SGD来讲，如果某个模型副本的一台机器失效，其他模型副本仍然继续处理样本并更新参数服务器中的模型参数。另一方面，Downpour SGD带来的多种异步处理形式给优化过程带来了进一步的随机性。这里面最显而易见的是，模型实例最可能是使用一个稍微过时的参数来计算梯度，因为这时其他的副本可能已经更新了参数服务器上的参数。但是，除此之外还有其他随机的来源：因为参数服务器组的每台机器是行为独立的，所以无法保证在给定时间点上，每个节点的参数被更新的次数相同，或者以同样的顺序被更新。更进一步的，因为模型副本使用不同的线程来获取参数和推送梯度值，故在同一时间戳上，单个副本内的参数将有额外的稍微不一致的现象。尽管对于非凸问题的这些操作的安全性缺乏理论基础，但是在实践中，我们发现放松一致性要求的做法是相当有效的。</p>
<p>我们发现，另外一项能极大提高Downpour SGD鲁棒性的技术是使用Adagrad[10]自适应学习速率方法。与使用固定的值作为学习速率的方式不同，Adagrad的每个参数使用单独的自适应学习速率。<br>可以看出，因为学习速率的计算仅与参数历史梯度值的平方和有关，所以Adagrad易于在每个参数服务器节点上单独实现。所有学习速率共享的缩放常量因子γ，通常大于（可能有一个数量级）不使用Adagrad情况下，采用固定学习速率的最优值。Adagrad的使用能够增加并发训练的模型副本数量，同时，采用“热启动”（即在启动其他副本之前，用单个模型来训练参数）的模型训练方法，几乎消除了在Downpour SGD中可能会出现的稳定性问题.</p>
<p>假设$\eta_{i,k}$是第i个参数在第k次迭代时的学习速率,$\Delta g_{i,k}$是其梯度值,那么：<br>\begin{equation}<br>\eta_{i,k}=\frac{\gamma}{\sqrt{\sum^k_{j=1} g_{i,k}}}<br>\end{equation}<br><img src="/2016/10/06/Downpour-SGD/downpour.jpeg" alt="downpour.jpeg" title=""></p>
<h2 id="Sandblaster-L-BFGS"><a href="#Sandblaster-L-BFGS" class="headerlink" title="Sandblaster L-BFGS"></a>Sandblaster L-BFGS</h2><p>已经证实批量处方法在小型深度网络的训练上效果很好[7]。为了将这些方法运用到大型模型和大型数据集上，我们引入了Sandblaster批量优化框架，同时讨论了L-BFGS在该框架的一个实现。 Sandblaster的主要思路是将参数的存储和操作分布化，算法（如L-BFGS）的核心位于协调器（coordinator）中。该协调器并不直接获取模型参数，相反地，它发出一系列命令（如内积，向量缩放，系数相关加法，乘法）到参数服务器节点，并且这些命令能在节点范围内执行。一些额外的信息，如L-BFGS的历史数据缓存，同样保存在计算出它的参数服务器节点上。这使得运行大型模型（10亿级参数）成为现实，而且不会因传输参数和梯度过度集中在一个节点上而导致性能下降。 在典型的L-BFGS的并行实现中，数据被分布到许多机器上，每个机器负责对样本数据的一个特定的子集计算梯度，而后梯度值被传输回中心服务器（或者通过树形结构来聚合[16]）。因为许多方法都需要等待最慢的机器处理完毕，所以它并不能很好地扩展到大型共享集群中。为了解决该（扩展性）问题，我们采用了如下的负载均衡的方案：协调器分配给这N个模型副本一小部分的任务量，并且该计算任务远小于总批量，每当副本完成计算处于闲置状态时，立即给其分配新的计算任务，如此下去。为了在整个批量计算的最后阶段进一步优化慢速副本的任务处理，协调器调度最快结束的副本同时计算未完成的任务，从最先结束的副本处取得计算结果。该方案和MapReduce中的“备份任务”的使用相类似[24]。数据预取方式和通过将顺序数据传输到同一生产者以提高数据亲和性的方法一道，使得数据的获取不再是问题。和Downpour SGD中和参数服务器之间的高频率，高吞吐参数同步方式相反，Sandblaster中的计算者仅仅需在每次批处理的开始阶段获取参数，并且只需在极少的结束部分（用以免遭备份失效和重启）处需要传输梯度到参数服务器。</p>
<img src="/2016/10/06/Downpour-SGD/sandblaster.jpeg" alt="sandblaster.jpeg" title="">
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>我们用两个不同的深度学习问题来衡量了我们设计的优化算法：(i)静态图像的物体识别和(ii)语音识别的声学处理。<br>语音识别任务是将一小段音频的中心区域（或帧）归类为数千种类型之一。我们使用了一个五层的深度网络：四个隐藏层，每个有2560个单元，并以sigmoid为激励函数；一个有8192个单元的softmax输出层。输入层是11个长度为25ms连续的相互重叠的语音，每个由40个对数动能值表示。层与层之间是全连接的，因此整个网络的参数数量有42M。我们用1.1G个弱标记样本集来训练模型，并且用保留的部分样本做测试集来衡量精确度。简单深度网络的配置和训练过程请参照[28]。<br>对于可视物体识别，我们训练了一个更大的局部区域连通的神经网络，并作用于ImageNet的有$1.6\times {10}^7$ 图像的数据集上，每个图像被缩放到100X100像素大小。整个网络有三个阶段，每个阶段都包含了过滤，池化，局部对比度归一化等操作，过滤层的每一个单元都和其前一层的10X10的小块图像相连接。我们的基础设施允许多个单元都和同一小块图像相连接，我们的实验中，同一连接单元数量从8增加到36不等。输出层由$2.1\times 10^4$个一对多模式的logistic分类器组成，每个分别代表ImageNet的一个物体种类。相似的深度网络配置和训练过程请参照[30]。</p>
<h2 id="模型并行基准测试"><a href="#模型并行基准测试" class="headerlink" title="模型并行基准测试"></a>模型并行基准测试</h2><p>为了测试DistBelief模型的并行性扩展，实验中以运行单个模型实例的划分（机器）数量作为变量，我们测量了用简单SGD训练处理单个mini-batch的平均时间。在图3中，我们通过计算训练的平均加速比来量化N个节点对并行化的影响：使用单个节点训练花费的时间对使用N个节点训练花费的时间的比值。模型中推断过程的加速比是相似的，因而没有显示出来。<br>中等大小的语音模型在8个机器节点上运行是最快的，相比于单个节点，加速比大约是2.2（每台机器配置其使用不超过20核CPU来训练模型）。将模型划分在大于8个机器节点上实际上会减缓训练过程，因为模型的全连通结构使得此时网络开销开始起决定性因素，同时节点的增加使得每个节点的计算量也相应地减少。<br><img src="/2016/10/06/Downpour-SGD/experiment1.png" alt="四个不同规模的深度网络使用单个DistBelief实例训练在集群机器不同规模下的加速比。具有较多参数的模型在机器增加时比较少参数模型获得更高的加速比" title="四个不同规模的深度网络使用单个DistBelief实例训练在集群机器不同规模下的加速比。具有较多参数的模型在机器增加时比较少参数模型获得更高的加速比"><br><img src="/2016/10/06/Downpour-SGD/experiment2.png" alt="左图：采用不同的优化方法，在（在一部分训练集）上的训练精度。右图：训练时间的变化下，测试集的分类精度的变化曲线。Downpour SGD和Sandblaster实验均采用了10小时平凡SGD热启动方式来初始化。" title="左图：采用不同的优化方法，在（在一部分训练集）上的训练精度。右图：训练时间的变化下，测试集的分类精度的变化曲线。Downpour SGD和Sandblaster实验均采用了10小时平凡SGD热启动方式来初始化。"><br>相反地，比语音识别模型规模更大，且具有局部连通性的图像模型，能够通过持续给每个模型副本增加节点数量，来提升加速比。可以看出，具有$1.7\times 10^9$个参数的最大模型加速比最高，在使用了81个节点的情况下，获了12倍的加速比。对于大型模型来讲，通过持续增加机器数量始终能提升训练速度，但是获得的性能回报逐渐变少。<br>优化方法的比较：为了衡量提出的分布优化方式的性能，我们在不同的配置下，运行前面提及的语音模型。考虑两种基准方式（译者注：作为比较的靶对象）：(i)用传统（单个副本）SGD方法训练DistBelief模型（在8个划分上），(ii)用CUDA[28]在GPU上训练与(i)中同样的模型。三个和基准方式相比较的分布优化方法是：(i)固定学习速率的Downpour SGD，(ii)使用Adagrad自适应学习速率的Downpour SGD，(iii)Sandblaster L-BFGS。<br>图4说明了对于不同的优化方法，以训练时间作为分类的性能时的模型比较。我们的目标是忽略资源要求下，在最短的训练时间内，获得最佳的测试集分类精度。传统单副本的SGD（黑色曲线）是最慢速的。具有20个副本的Downpour SGD方法（蓝色曲线）在此基础上获得了显著的提升。20个副本的Downpour SGD和Adagrad相结合（橙色曲线）是可以被认为是中等速率的，而使用了2000个模型副本的Sandblaster L-BFGS更加快速（绿色曲线）。但是，最快的是200个模型副本并和Adagrad相结合的Downpour SGD方法（红色曲线）。可见，只要供给足够的CPU资源，Sandblaster L-BFGS和Downpour SGD方法对模型的训练都能从本质上快于高性能GPU。<br>尽管我们没有限制以上实验的资源使用，但是我们可以考虑这些优化方法是如何用硬件资源来换取性能提升的。将测试集精度设定为固定值（16%），在改变机器数量和CPU数量的条件下，测试上述方法达到该精度所需训练时间，以此方式来分析资源使用和性能的关系，如图5。每条曲线的四个点其中之一对应于图4中的训练配置，其他三个点是替代的配置。<br><img src="/2016/10/06/Downpour-SGD/experiment3.png" alt="在不同机器数量（左图）和CPU数量（右图）下，几种优化策略达到固定精度值（16%）所花费的时间" title="在不同机器数量（左图）和CPU数量（右图）下，几种优化策略达到固定精度值（16%）所花费的时间"><br>在此坐标图中，距原点较近的点更优，因为它们在更少硬件资源的条件下，花费的训练时间更少。从这个角度上讲，使用Adagrad的Downpour SGD方法看起来是最好的权衡：对于任意固定机器数量或CPU数量条件下，该方法比Downpour SGD或Sandblaster L-BFGS花费更少的时间达到精度目标。对于任意给定达到精度目标的训练时间，使用Adagrad的Downpour SGD比Sandblaster L-BFGS使用更少的资源，并且在多数情况下，使用固定学习速率的Downpour SGD甚至都不能在最后期限内完成训练目标。Sandblaster L-BFGS看起来还能通过持续增加CPU数量来提高加速比，表明在极其大的（如3*10^4CPU使用量）资源使用条件下，应该会获得最快的训练时间。</p>
<h2 id="应用到ImageNet"><a href="#应用到ImageNet" class="headerlink" title="应用到ImageNet"></a>应用到ImageNet</h2><p>先前的实验证明了，我们的技术可以加速具有$10^7$参数数量的神经网络训练。但是，对于这些基于集群的分布式优化方法来讲，最有价值的优点，是它能扩展到远大于单个机器能够容纳得下的模型，更不用说单个GPU了。为了测试训练大型神经网络的能力，我们使用Downpour SGD训练了之前提及的具有$1.7\times 10^9$个参数的图像模型，用于分类任务。正如[30]中的细节描述，在ImageNet分类任务中，这个网络的训练结果获得了大约错误率15%交叉验证（Cross-Validation）的分类精度，比我们所已知的先前最高的精度提高了60%多。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在这篇文章中，我们介绍了DistBelief，一个深度网络的分布并行训练的框架，并在该框架中发现了一些有效的分布优化策略。我们提出了Downpour SGD，一个高度异步的SGD变种算法，用以训练非凸的深度学习模型，其结果出乎意料的好。Sandblaster L-BFGS， L-BFGS的分布式实现，其与SGD相比具有竞争力。同时，对网络带宽的高效利用，使得其能够扩展到更大数量的并发线程来训练同一模型。这就是说，当具有2000数量CPU或更少时，Downpour SGD和Adagrad自适应学习速率方法的结合是最有效的方法。 Adagrad方法本身不是为异步SGD的使用而设计的，并且该方法最典型的应用也不是在非凸问题上。但是，在高度非线性的深度网络中，两者的结合的效果却如此的好。我们推测，在面对剧烈的异步更新时，Adagrad自动地对不稳定参数起到了稳定的效果，并且很自然地根据不同的深度网络层数的变化来调整学习速率。 实验结果表明，即使在中等规模的模型训练上，使用我们的大规模（分布式）方法，集群方法也比GPU要快，并且没有GPU对模型规模的限制。为了证明其训练更大模型的能力，我们通过训练一个超过10^9数量参数的模型，在ImageNet物体识别上获得了比先前最优的更好的精度水平。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>G. Dahl, D. Yu, L. Deng, and A. Acero. Context-dependent pre-trained deep neural networks for large vocabulary speech recognition. IEEE Transactions on Audio, Speech, and Language Processing, 2012.</li>
<li>G. Hinton, L. Deng, D. Yu, G. Dahl, A. Mohamed, N. Jaitly, A. Senior, V. Vanhoucke, P. Nguyen, T. Sainath, and B. Kingsbury. Deep neural networks for acoustic modeling in speech recognition. IEEE Signal Processing Magazine, 2012.</li>
<li>D. C. Ciresan, U. Meier, L. M. Gambardella, and J. Schmidhuber. Deep big simple neural nets excel on handwritten digit recognition. CoRR, 2010.</li>
<li>A. Coates, H. Lee, and A. Y. Ng. An analysis of single-layer networks in unsupervised feature learning. In AISTATS 14, 2011.</li>
<li>Y. Bengio, R. Ducharme, P. Vincent, and C. Jauvin. A neural probabilistic language model. Journal of Machine Learning Research, 3:1137–1155, 2003.</li>
<li>R. Collobert and J. Weston. A unified architecture for natural language processing: Deep neural networks with multitask learning. In ICML, 2008.</li>
<li>Q. V. Le, J. Ngiam, A. Coates, A. Lahiri, B. Prochnow, and A. Y. Ng. On optimization methods for deep learning. In ICML, 2011.</li>
<li>R. Raina, A. Madhavan, and A. Y. Ng. Large-scale deep unsupervised learning using graphics processors. In ICML, 2009.</li>
<li>J. Martens. Deep learning via hessian-free optimization. In ICML, 2010.</li>
<li>J. C. Duchi, E. Hazan, and Y. Singer. Adaptive subgradient methods for online learning and stochastic optimization. Journal of Machine Learning Research, 12:2121–2159, 2011.</li>
<li>Q. Shi, J. Petterson, G. Dror, J. Langford, A. Smola, A. Strehl, and V. Vishwanathan. Hash kernels. In AISTATS, 2009.</li>
<li>J. Langford, A. Smola, and M. Zinkevich. Slow learners are fast. In NIPS, 2009.</li>
<li>G. Mann, R. McDonald, M. Mohri, N. Silberman, and D. Walker. Efficient large-scale distributed training of conditional maximum entropy models. In NIPS, 2009.</li>
<li>R. McDonald, K. Hall, and G. Mann. Distributed training strategies for the structured perceptron. In NAACL, 2010.</li>
<li>M. Zinkevich, M. Weimer, A. Smola, and L. Li. Parallelized stochastic gradient descent. In NIPS, 2010.</li>
<li>A. Agarwal, O. Chapelle, M. Dudik, and J. Langford. A reliable effective terascale linear learning system. In AISTATS, 2011.</li>
<li>A. Agarwal and J. Duchi. Distributed delayed stochastic optimization. In NIPS, 2011.</li>
<li>C. H. Teo, Q. V. Le, A. J. Smola, and S. V. N. Vishwanathan. A scalable modular convex solver for regularized risk minimization. In KDD, 2007.</li>
<li>F. Niu, B. Retcht, C. Re, and S. J. Wright. Hogwild! A lock-free approach to parallelizing stochastic gradient descent. In NIPS, 2011.</li>
<li>J. Bergstra, O. Breuleux, F. Bastien, P. Lamblin, R. Pascanu, G. Desjardins, J. Turian, D. Warde-Farley, and Y. Bengio. Theano: a CPU and GPU math expression compiler. In SciPy, 2010.</li>
<li>D. Ciresan, U. Meier, and J. Schmidhuber. Multi-column deep neural networks for image classification. Technical report, IDSIA, 2012.</li>
<li>L. Deng, D. Yu, and J. Platt. Scalable stacking and learning for building deep architectures. In ICASSP, 2012.</li>
<li>A. Krizhevsky. Learning multiple layers of features from tiny images. Technical report, U. Toronto, 2009.</li>
<li>J. Dean and S. Ghemawat. Map-Reduce: simplified data processing on large clusters. CACM, 2008.</li>
<li>Y. Low, J. Gonzalez, A. Kyrola, D. Bickson, C. Guestrin, and J. Hellerstein. Distributed GraphLab: A framework for machine learning in the cloud. In VLDB, 2012.</li>
<li>L. Bottou. Stochastic gradient learning in neural networks. In Proceedings of Neuro-Nˆımes 91, 1991.</li>
<li>Y. LeCun, L. Bottou, G. Orr, and K. Muller. Efficient backprop. In Neural Networks: Tricks of the trade. Springer, 1998.</li>
<li>V. Vanhoucke, A. Senior, and M. Z. Mao. Improving the speed of neural networks on cpus. In Deep Learning and Unsupervised Feature Learning Workshop, NIPS 2011, 2011.</li>
<li>J. Deng, W. Dong, R. Socher, L. -J. Li, K. Li, and L. Fei-Fei. ImageNet: A Large-Scale Hierarchical</li>
<li>Image Database. In CVPR, 2009. 30. Q. V. Le, M. A. Ranzato, R. Monga, M. Devin, K. Chen, G. S. Corrado, J. Dean, and A. Y. Ng. Building high-level features using large scale unsupervised learning. In ICML, 2012.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux常见文字处理命令]]></title>
      <url>http://wlyPKU.github.io/2016/08/30/Linux%E5%B8%B8%E8%A7%81%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>本文主要介绍Linux的常见文字处理命令,如awk, sort, uniq 等操作。<br><a id="more"></a></p>
<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。<br>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。<br>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml">awk '</span><span class="template-variable">&#123;pattern + action&#125;</span><span class="xml">' </span><span class="template-variable">&#123;filenames&#125;</span><span class="xml"></span></div></pre></td></tr></table></figure>
<p>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（<code>{}</code>）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。<br>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。<br>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p>
<h2 id="调用awk"><a href="#调用awk" class="headerlink" title="调用awk"></a>调用awk</h2><p>有三种方式调用awk:<br>1.命令行方式<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk [-F  field-<span class="keyword">separator</span>]  <span class="string">'commands'</span>  input-<span class="keyword">file</span>(s)</div></pre></td></tr></table></figure></p>
<p>其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。<br>在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。<br>2.shell脚本方式<br>将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。<br>相当于shell脚本首行的：<code>#!/bin/sh</code><br>可以换成：<code>#!/bin/awk</code><br>3.将所有的awk命令插入一个单独文件，然后调用：<br><code>awk -f awk-script-file input-file(s)</code><br>其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</p>
<h2 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h2><p>假设last -n 5的输出如下<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[<span class="name">root@www</span> ~]# last -n <span class="number">5</span> &lt;==仅取出前五行</div><div class="line">root     pts/1   <span class="number">192.168</span>.1.100  Tue Feb <span class="number">10</span> <span class="number">11</span>:21   still logged in</div><div class="line">root     pts/1   <span class="number">192.168</span>.1.100  Tue Feb <span class="number">10</span> <span class="number">00</span>:46 - <span class="number">02</span>:28  (<span class="name">01:41</span>)</div><div class="line">root     pts/1   <span class="number">192.168</span>.1.100  Mon Feb  <span class="number">9</span> <span class="number">11</span>:41 - <span class="number">18</span>:30  (<span class="name">06:48</span>)</div><div class="line">dmtsai   pts/1   <span class="number">192.168</span>.1.100  Mon Feb  <span class="number">9</span> <span class="number">11</span>:41 - <span class="number">11</span>:41  (<span class="name">00:00</span>)</div><div class="line">root     tty1                   Fri Sep  <span class="number">5</span> <span class="number">14</span>:09 - <span class="number">14</span>:10  (<span class="name">00:01</span>)</div></pre></td></tr></table></figure></p>
<p>如果只是显示最近登录的5个帐号<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#last -n 5 | awk  <span class="string">'&#123;print $1&#125;'</span></span></div><div class="line">root</div><div class="line">root</div><div class="line">root</div><div class="line">dmtsai</div><div class="line">root</div></pre></td></tr></table></figure></p>
<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。</p>
<p>如果只是显示/etc/passwd的账户<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#cat /etc/passwd |awk  -F <span class="string">':'</span>  <span class="string">'&#123;print $1&#125;'</span>  </span></div><div class="line">root</div><div class="line">daemon</div><div class="line">bin</div><div class="line">sys</div></pre></td></tr></table></figure></p>
<p>这种是awk+action的示例，每行都会执行action{print $1}。</p>
<p>-F指定域分隔符为’:’。</p>
<p>如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">cat</span> /etc/passwd |awk  -F ':'  '&#123;<span class="keyword">print</span> <span class="variable">$1</span><span class="string">"\t"</span><span class="variable">$7&#125;</span>'</div><div class="line">root    /bin/bash</div><div class="line">daemon  /bin/<span class="keyword">sh</span></div><div class="line">bin     /bin/<span class="keyword">sh</span></div><div class="line">sys     /bin/<span class="keyword">sh</span></div></pre></td></tr></table></figure></p>
<p>如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,/bin/nosh”。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cat</span> /etc/passwd |awk  -F ':'  'BEGIN &#123;<span class="keyword">print</span> <span class="string">"name,shell"</span>&#125;  &#123;<span class="keyword">print</span> <span class="variable">$1</span><span class="string">","</span><span class="variable">$7&#125;</span> END &#123;<span class="keyword">print</span> <span class="string">"blue,/bin/nosh"</span>&#125;'</div><div class="line">name,<span class="keyword">shell</span></div><div class="line">root,/bin/bash</div><div class="line">daemon,/bin/<span class="keyword">sh</span></div><div class="line">bin,/bin/<span class="keyword">sh</span></div><div class="line">sys,/bin/<span class="keyword">sh</span></div><div class="line">....</div><div class="line">blue,/bin/nosh</div></pre></td></tr></table></figure>
<p>awk工作流程是这样的：先执行BEGING，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。</p>
<p>搜索/etc/passwd有root关键字的所有行<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#awk -F: '/root/' /etc/passwd</span></div><div class="line"><span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></div></pre></td></tr></table></figure></p>
<p>这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。<br>搜索支持正则，例如找root开头的: awk -F: ‘/^root/‘ /etc/passwd</p>
<p>搜索/etc/passwd有root关键字的所有行，并显示对应的shell<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># awk -F: <span class="string">'/root/&#123;print $7&#125;'</span> <span class="regexp">/etc/</span>passwd</div><div class="line"><span class="regexp">/bin/</span>bash</div></pre></td></tr></table></figure></p>
<p> 这里指定了action{print $7}</p>
<h2 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h2><p>awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ARGC               命令行参数个数</div><div class="line">ARGV               命令行参数排列</div><div class="line">ENVIRON            支持队列中系统环境变量的使用</div><div class="line">FILENAME           awk浏览的文件名</div><div class="line">FNR                浏览文件的记录数</div><div class="line"><span class="built_in">FS</span>                 设置输入域分隔符，等价于命令行 -F选项</div><div class="line">NF                 浏览记录的域的个数</div><div class="line">NR                 已读的记录数</div><div class="line">OFS                输出域分隔符</div><div class="line">ORS                输出记录分隔符</div><div class="line">RS                 控制记录分隔符</div></pre></td></tr></table></figure></p>
<p>此外,$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,……以此类推。</p>
<p>统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#awk  -F ':'  '&#123;print "filename:" FILENAME ",linenumber:" NR ",columns:" NF ",linecontent:"$0&#125;' /etc/passwd</span></div><div class="line"><span class="symbol">filename:</span>/etc/passwd,<span class="symbol">linenumber:</span><span class="number">1</span>,<span class="symbol">columns:</span><span class="number">7</span>,<span class="symbol">linecontent:</span><span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></div><div class="line"><span class="symbol">filename:</span>/etc/passwd,<span class="symbol">linenumber:</span><span class="number">2</span>,<span class="symbol">columns:</span><span class="number">7</span>,<span class="symbol">linecontent:</span><span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/bin/sh</span></div><div class="line"><span class="symbol">filename:</span>/etc/passwd,<span class="symbol">linenumber:</span><span class="number">3</span>,<span class="symbol">columns:</span><span class="number">7</span>,<span class="symbol">linecontent:</span><span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/bin/sh</span></div><div class="line"><span class="symbol">filename:</span>/etc/passwd,<span class="symbol">linenumber:</span><span class="number">4</span>,<span class="symbol">columns:</span><span class="number">7</span>,<span class="symbol">linecontent:</span><span class="symbol">sys:</span><span class="symbol">x:</span><span class="number">3</span><span class="symbol">:</span><span class="number">3</span><span class="symbol">:sys</span><span class="symbol">:/dev</span><span class="symbol">:/bin/sh</span></div></pre></td></tr></table></figure></p>
<p>使用printf替代print,可以让代码更加简洁，易读<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">awk</span>  -F <span class="string">':'</span>  <span class="string">'&#123;printf("filename:%10s,linenumber:%s,columns:%s,linecontent:%s\n",FILENAME,NR,NF,<span class="variable">$0</span>)&#125;'</span> /etc/passwd</div></pre></td></tr></table></figure></p>
<h2 id="awk编程"><a href="#awk编程" class="headerlink" title="awk编程"></a>awk编程</h2><h3 id="变量和赋值"><a href="#变量和赋值" class="headerlink" title="变量和赋值"></a>变量和赋值</h3><p>除了awk的内置变量，awk还可以自定义变量。</p>
<p>下面统计/etc/passwd的账户人数<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'&#123;count++;print $0;&#125; END&#123;print "user count is ", count&#125;'</span> /etc/passwd</div><div class="line"><span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></div><div class="line">......</div><div class="line">user count is  <span class="number">40</span></div></pre></td></tr></table></figure></p>
<p>count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。</p>
<p>这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk '<span class="type">BEGIN</span> &#123;<span class="built_in">count</span>=<span class="number">0</span>;<span class="built_in">print</span> <span class="string">"[start]user count is "</span>, <span class="built_in">count</span>&#125; &#123;<span class="built_in">count</span>=<span class="built_in">count</span>+<span class="number">1</span>;<span class="built_in">print</span> $<span class="number">0</span>;&#125; <span class="type">END</span>&#123;<span class="built_in">print</span> <span class="string">"[end]user count is "</span>, <span class="built_in">count</span>&#125;' /etc/passwd</div><div class="line">[start]user <span class="built_in">count</span> <span class="keyword">is</span>  <span class="number">0</span></div><div class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</div><div class="line">...</div><div class="line">[end]user <span class="built_in">count</span> <span class="keyword">is</span>  <span class="number">40</span></div></pre></td></tr></table></figure></p>
<p>统计某个文件夹下的文件占用的字节数<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk <span class="symbol">'BEGIN</span> &#123;size=<span class="number">0</span>;&#125; &#123;size=size+$<span class="number">5</span>;&#125; <span class="keyword">END</span>&#123;print <span class="string">"[end]size is "</span>, size&#125;'</div><div class="line">[<span class="keyword">end</span>]size <span class="keyword">is</span>  <span class="number">8657198</span></div></pre></td></tr></table></figure></p>
<p>如果以M为单位显示:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk 'BEGIN &#123;size=<span class="number">0</span>;&#125; &#123;size=size+$<span class="number">5</span>;&#125; END&#123;print <span class="string">"[end]size is "</span>, size/<span class="number">1024</span>/<span class="number">1024</span>,<span class="string">"M"</span>&#125;' </div><div class="line">[end]size is  <span class="number">8.25889</span> M</div></pre></td></tr></table></figure></p>
<p>注意，统计不包括文件夹的子目录。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p> awk中的条件语句是从C语言中借鉴来的，见如下声明方式：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (expression) &#123;</div><div class="line">    statement;</div><div class="line">    statement;</div><div class="line">    ... ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (expression) &#123;</div><div class="line">    statement;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    statement2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (expression) &#123;</div><div class="line">    statement1;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (expression1) &#123;</div><div class="line">    statement2;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    statement3;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹):<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk '<span class="keyword">BEGIN</span> &#123;<span class="keyword">size</span>=<span class="number">0</span>;print "[<span class="keyword">start</span>]<span class="keyword">size</span> <span class="keyword">is</span> <span class="string">", size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print "</span>[<span class="keyword">end</span>]<span class="keyword">size</span> <span class="keyword">is</span> <span class="string">", size/1024/1024,"</span>M<span class="string">"&#125;' </span></div><div class="line">[end]size is  8.22339 M</div></pre></td></tr></table></figure></p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>  因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。</p>
<p>显示/etc/passwd的账户<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">awk -F ':' 'BEGIN &#123;<span class="built_in">count</span>=<span class="number">0</span>;&#125; &#123;<span class="built_in">name</span>[<span class="built_in">count</span>] = $<span class="number">1</span>;<span class="built_in">count</span>++;&#125;; END&#123;<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR; i++) print i, <span class="built_in">name</span>[i]&#125;' /etc/passwd</div><div class="line"><span class="number">0</span> root</div><div class="line"><span class="number">1</span> daemon</div><div class="line"><span class="number">2</span> bin</div><div class="line"><span class="number">3</span> sys</div><div class="line"><span class="number">4</span> sync</div><div class="line"><span class="number">5</span> games</div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>这里使用for循环遍历数组</p>
<p>awk编程的内容极多，这里只罗列简单常用的用法，更多请参考<a href="http://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="external">The GNU Awk User’s Guide</a></p>
<hr>
<h1 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h1><p>uniq的作用是过滤重复部分显示文件内容，这个命令读取输入文件，并比较相邻的行。在正常情况下，第二个及以后更多个重复行将被删去，行比较是根据所用字符集的排序序列进行的。该命令加工后的结果写到输出文件中。输入文件和输出文件必须不同。如果输入文件用“- ”表示，则从标准输入读取。<br>该命令各选项含义如下：</p>
<p>– c 显示输出中，在每行行首加上本行在文件中出现的次数。它可取代- u和- d选项。<br>– d 只显示重复行。<br>– u 只显示文件中不重复的各行。<br>– n 前n个字段与每个字段前的空白一起被忽略。一个字段是一个非空格、非制表符的字符串，彼此由制表符和空格隔开(字段从0开始编号)。<br>+n 前n个字符被忽略，之前的字符被跳过(字符从0开始编号)。<br>– f n 与- n相同，这里n是字段数。<br>– s n 与+n相同，这里n是字符数。</p>
<p>接下来通过实践实例说明：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="comment"># cat test</span></div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line">girl took <span class="keyword">bat </span>home</div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line">dog <span class="keyword">brought </span>hat home</div><div class="line">dog <span class="keyword">brought </span>hat home</div><div class="line">dog <span class="keyword">brought </span>hat home</div></pre></td></tr></table></figure></p>
<p>看test文件的内容<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="comment"># uniq test</span></div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line">girl took <span class="keyword">bat </span>home</div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line">dog <span class="keyword">brought </span>hat home</div></pre></td></tr></table></figure></p>
<p>uniq命令不加任何参数，仅显示连续重复的行一次</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="comment"># uniq -c test</span></div><div class="line"><span class="number">2</span> <span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="number">1</span> girl took <span class="keyword">bat </span>home</div><div class="line"><span class="number">2</span> <span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="number">3</span> dog <span class="keyword">brought </span>hat home</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure>
<p>-c 参数显示文件中每行连续出现的次数。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="comment"># cat test |sort | uniq -c</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="number">3</span> dog <span class="keyword">brought </span>hat home</div><div class="line"><span class="number">1</span> girl took <span class="keyword">bat </span>home</div></pre></td></tr></table></figure>
<p>排序后再显示</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="comment"># uniq -d test</span></div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line">dog <span class="keyword">brought </span>hat home</div></pre></td></tr></table></figure>
<p>-d选项仅显示文件中连续重复出现的行。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="meta"># uniq -u test</span></div><div class="line">girl took bat <span class="built_in">home</span></div></pre></td></tr></table></figure>
<p>-u选项显示文件中没有连续出现的行。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="comment"># uniq -f 2 -s 2 test</span></div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div></pre></td></tr></table></figure>
<p>忽略每行的前2个字段，忽略第二个空白字符和第三个字段的首字符，结果at home</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="comment"># uniq -f 1 test</span></div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line">dog <span class="keyword">brought </span>hat home</div></pre></td></tr></table></figure>
<p>忽略每行的第一个字段，这样boy ，girl开头的行看起来是连续重复的行。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@stu100 ~]<span class="comment"># uniq -D test</span></div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line"><span class="keyword">boy </span>took <span class="keyword">bat </span>home</div><div class="line">dog <span class="keyword">brought </span>hat home</div><div class="line">dog <span class="keyword">brought </span>hat home</div><div class="line">dog <span class="keyword">brought </span>hat home</div></pre></td></tr></table></figure>
<p>显示所有重复的行，每个重复的行都显示</p>
<hr>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><p>功能说明：将文本文件内容加以排序。<br>语　　法：sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]<br>补充说明：sort可针对文本文件的内容，以行为单位来排序。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[rocrocket<span class="variable">@rocrocket</span> programming]<span class="variable">$ </span>cat seq.txt</div><div class="line">banana</div><div class="line">apple</div><div class="line">pear</div><div class="line">orange</div><div class="line">[rocrocket<span class="variable">@rocrocket</span> programming]<span class="variable">$ </span>sort seq.txt</div><div class="line">apple</div><div class="line">banana</div><div class="line">orange</div><div class="line">pear</div></pre></td></tr></table></figure></p>
<p>参　　数：<br>  -b   忽略每行前面开始出的空格字符。<br>  -c   检查文件是否已经按照顺序排序。<br>  -d   排序时，处理英文字母、数字及空格字符外，忽略其他的字符。<br>  -f   排序时，将小写字母视为大写字母。<br>  -i   排序时，除了040至176之间的ASCII字符外，忽略其他的字符。<br>  -m   将几个排序好的文件进行合并。<br>  -M   将前面3个字母依照月份的缩写进行排序。<br>  -n   依照数值的大小排序。<br>  -o&lt;输出文件&gt;   将排序后的结果存入指定的文件。<br>  -r   以相反的顺序来排序。<br>  -t&lt;分隔字符&gt;   指定排序时所用的栏位分隔字符。<br>  +&lt;起始栏位&gt;-&lt;结束栏位&gt;   以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。<br>  –help   显示帮助。<br>  –version   显示版本信息</p>
<p>sort的-n、-r、-k、-t选项的使用：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[root@mail text]</span># <span class="selector-tag">cat</span> <span class="selector-tag">sort</span><span class="selector-class">.txt</span> </div><div class="line"><span class="selector-tag">AAA</span><span class="selector-pseudo">:BB</span><span class="selector-pseudo">:CC</span> </div><div class="line"><span class="selector-tag">aaa</span><span class="selector-pseudo">:30</span><span class="selector-pseudo">:1.6</span> </div><div class="line"><span class="selector-tag">ccc</span><span class="selector-pseudo">:50</span><span class="selector-pseudo">:3.3</span> </div><div class="line"><span class="selector-tag">ddd</span><span class="selector-pseudo">:20</span><span class="selector-pseudo">:4.2</span> </div><div class="line"><span class="selector-tag">bbb</span><span class="selector-pseudo">:10</span><span class="selector-pseudo">:2.5</span> </div><div class="line"><span class="selector-tag">eee</span><span class="selector-pseudo">:40</span><span class="selector-pseudo">:5.4</span> </div><div class="line"><span class="selector-tag">eee</span><span class="selector-pseudo">:60</span><span class="selector-pseudo">:5.1</span></div><div class="line"></div><div class="line">#将<span class="selector-tag">BB</span>列按照数字从小到大顺序排列： </div><div class="line"><span class="selector-attr">[root@mail text]</span># <span class="selector-tag">sort</span> <span class="selector-tag">-nk</span> 2 <span class="selector-tag">-t</span>: <span class="selector-tag">sort</span><span class="selector-class">.txt</span> </div><div class="line"><span class="selector-tag">AAA</span><span class="selector-pseudo">:BB</span><span class="selector-pseudo">:CC</span> </div><div class="line"><span class="selector-tag">bbb</span><span class="selector-pseudo">:10</span><span class="selector-pseudo">:2.5</span> </div><div class="line"><span class="selector-tag">ddd</span><span class="selector-pseudo">:20</span><span class="selector-pseudo">:4.2</span> </div><div class="line"><span class="selector-tag">aaa</span><span class="selector-pseudo">:30</span><span class="selector-pseudo">:1.6</span> </div><div class="line"><span class="selector-tag">eee</span><span class="selector-pseudo">:40</span><span class="selector-pseudo">:5.4</span> </div><div class="line"><span class="selector-tag">ccc</span><span class="selector-pseudo">:50</span><span class="selector-pseudo">:3.3</span> </div><div class="line"><span class="selector-tag">eee</span><span class="selector-pseudo">:60</span><span class="selector-pseudo">:5.1</span> </div><div class="line"></div><div class="line">#将<span class="selector-tag">CC</span>列数字从大到小顺序排列： </div><div class="line"><span class="selector-attr">[root@mail text]</span># <span class="selector-tag">sort</span> <span class="selector-tag">-nrk</span> 3 <span class="selector-tag">-t</span>: <span class="selector-tag">sort</span><span class="selector-class">.txt</span> </div><div class="line"><span class="selector-tag">eee</span><span class="selector-pseudo">:40</span><span class="selector-pseudo">:5.4</span> </div><div class="line"><span class="selector-tag">eee</span><span class="selector-pseudo">:60</span><span class="selector-pseudo">:5.1</span> </div><div class="line"><span class="selector-tag">ddd</span><span class="selector-pseudo">:20</span><span class="selector-pseudo">:4.2</span> </div><div class="line"><span class="selector-tag">ccc</span><span class="selector-pseudo">:50</span><span class="selector-pseudo">:3.3</span> </div><div class="line"><span class="selector-tag">bbb</span><span class="selector-pseudo">:10</span><span class="selector-pseudo">:2.5</span> </div><div class="line"><span class="selector-tag">aaa</span><span class="selector-pseudo">:30</span><span class="selector-pseudo">:1.6</span> </div><div class="line"><span class="selector-tag">AAA</span><span class="selector-pseudo">:BB</span><span class="selector-pseudo">:CC</span> </div><div class="line"></div><div class="line"># <span class="selector-tag">-n</span>是按照数字大小排序，<span class="selector-tag">-r</span>是以相反顺序，<span class="selector-tag">-k</span>是指定需要爱排序的栏位，<span class="selector-tag">-t</span>指定栏位分隔符为冒号</div></pre></td></tr></table></figure></p>
<h2 id="k选项的具体语法格式："><a href="#k选项的具体语法格式：" class="headerlink" title="-k选项的具体语法格式："></a>-k选项的具体语法格式：</h2><p>-k选项的语法格式：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">FStart</span><span class="string">.</span><span class="comment">CStart</span> <span class="comment">Modifie</span><span class="string">,</span><span class="comment">FEnd</span><span class="string">.</span><span class="comment">CEnd</span> <span class="comment">Modifier</span> </div><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">Start</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">,</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">End</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> </div><div class="line">   <span class="comment">FStart</span><span class="string">.</span><span class="comment">CStart</span> <span class="comment">选项</span> <span class="string">,</span> <span class="comment">FEnd</span><span class="string">.</span><span class="comment">CEnd</span> <span class="comment">选项</span></div></pre></td></tr></table></figure></p>
<p>这个语法格式可以被其中的逗号<code>,</code>分为两大部分，Start部分和End部分。Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分。我们重点说说Start部分的FStart和C.Start。C.Start也是可以省略的，省略的话就表示从本域的开头部分开始。FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算“排序首字符”。同理，在End部分中，你可以设定FEnd.CEnd，如果你省略.CEnd，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。 </p>
<p>从公司英文名称的第二个字母开始进行排序：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sort -t ' ' -k <span class="number">1.2</span> facebook.txt </div><div class="line">baidu <span class="number">100</span> <span class="number">5000</span> </div><div class="line">sohu <span class="number">100</span> <span class="number">4500</span> </div><div class="line">google <span class="number">110</span> <span class="number">5000</span> </div><div class="line">guge <span class="number">50</span> <span class="number">3000</span></div></pre></td></tr></table></figure></p>
<p>使用了<code>-k 1.2</code>，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。你会发现baidu因为第二个字母是a而名列榜首。sohu和 google第二个字符都是o，但sohu的h在google的o前面，所以两者分别排在第二和第三。guge只能屈居第四了。</p>
<p>只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sort -t ' ' -k <span class="number">1.2</span>,<span class="number">1.2</span> -nrk <span class="number">3</span>,<span class="number">3</span> facebook.txt </div><div class="line">baidu <span class="number">100</span> <span class="number">5000</span> </div><div class="line">google <span class="number">110</span> <span class="number">5000</span> </div><div class="line">sohu <span class="number">100</span> <span class="number">4500</span> </div><div class="line">guge <span class="number">50</span> <span class="number">3000</span></div></pre></td></tr></table></figure></p>
<p>由于只对第二个字母进行排序，所以我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。对于员工工资进行排 序，我们也使用了-k 3,3，这是最准确的表述，表示我们“只”对本域进行排序，因为如果你省略了后面的3，就变成了我们“对第3个域开始到最后一个域位置的内容进行排序” 了。</p>
<p>综合示例:<br><strong>使用linux命令或者shell实现：文件words存放英文单词，格式为以空格分割（单词可以重复），统计这个文件中出现次数最多的前10个单词。</strong><br><figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@demo:~$ cat IHavaADream.txt | awk -F ' ' '&#123;for(i=1;i&lt;=NF;i++)print $i;&#125;'| sort | uniq -c | sort -k1,1nr | head -10</div><div class="line">    <span class="number"> 52 </span>of</div><div class="line">    <span class="number"> 48 </span>the</div><div class="line">    <span class="number"> 28 </span>to</div><div class="line">    <span class="number"> 24 </span>and</div><div class="line">    <span class="number"> 21 </span>a</div><div class="line">    <span class="number"> 20 </span>be</div><div class="line">    <span class="number"> 17 </span>will</div><div class="line">    <span class="number"> 14 </span>freedom</div><div class="line">    <span class="number"> 13 </span>have</div><div class="line">    <span class="number"> 13 </span>I</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符串全排列]]></title>
      <url>http://wlyPKU.github.io/2016/08/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<p>问题：给定字符串S，生成该字符串的全排列。<br>比如输入为abc，那么输出有以下几种：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">abc</span> acb <span class="keyword">bac </span><span class="keyword">bca </span>cab cba</div></pre></td></tr></table></figure></p>
<p>即如果输入字符串的长度为N的话，会输出N!个结果。<br>本文整理了求字符串全排列的若干方法。</p>
<a id="more"></a>
<h1 id="方法1-使用STL库的标准函数"><a href="#方法1-使用STL库的标准函数" class="headerlink" title="方法1 使用STL库的标准函数"></a>方法1 使用STL库的标准函数</h1><p>C++ STL中提供了std::next_permutation与std::prev_permutation可以获取数字或者是字符的全排列，其中std::next_permutation提供升序、std::prev_permutation提供降序。<br>1.std::next_permutation函数原型<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　template &lt;class <span class="keyword">BidirectionalIterator&gt;</span></div><div class="line">　　<span class="keyword">bool </span>next_permutation (<span class="keyword">BidirectionalIterator </span>first, <span class="keyword">BidirectionalIterator </span>last )<span class="comment">;</span></div><div class="line">　　template &lt;class <span class="keyword">BidirectionalIterator, </span>class <span class="built_in">Compare</span>&gt;</div><div class="line">　　<span class="keyword">bool </span>next_permutation (<span class="keyword">BidirectionalIterator </span>first,<span class="keyword">BidirectionalIterator </span>last, <span class="built_in">Compare</span> comp)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>说明：next_permutation，重新排列范围内的元素[第一，最后一个）返回按照字典序排列的下一个值较大的组合。<br>返回值：如果有一个更高的排列，它重新排列元素，并返回true；如果这是不可能的（因为它已经在最大可能的排列），它按升序排列重新元素，并返回false。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"aba"</span>;</div><div class="line">    <span class="built_in">std</span>::sort(s.begin(), s.end());</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">    &#125; <span class="keyword">while</span>(<span class="built_in">std</span>::next_permutation(s.begin(), s.end()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="方法2-仿STL库的标准函数实现"><a href="#方法2-仿STL库的标准函数实现" class="headerlink" title="方法2 仿STL库的标准函数实现"></a>方法2 仿STL库的标准函数实现</h1><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　[例]字符集&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,较小的数字较先,这样按字典序生成的全排列是:</div><div class="line">     　　　　<span class="number">123,132,213,231</span>,<span class="number">312,321</span></div></pre></td></tr></table></figure>
<p>※ 一个全排列可看做一个字符串，字符串可有前缀、后缀。<br>    生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[例]<span class="number">839647521</span>是<span class="number">1</span>-<span class="number">-9</span>的排列。<span class="number">1</span>—<span class="number">9</span>的排列最前面的是<span class="number">123456789</span>，最后面的<span class="number">987654321</span>，从右向左扫描若都是增的，就到了<span class="number">987654321</span>，也就没有下一个了。否则找出第一次出现下降的位置。</div></pre></td></tr></table></figure></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">【例】 一般而言，设P是[1,n]的一个全排列。</div><div class="line">　　　　　　P=P1P2…Pn=P1P2…Pj<span class="string">-1</span>PjPj<span class="string">+1</span>…Pk<span class="string">-1</span>PkPk<span class="string">+1</span>…Pn</div><div class="line">　　　　find:　　j=max&#123;i|Pi&lt;Pi<span class="string">+1</span>&#125;</div><div class="line">　　　　　　　　　k=max&#123;i|Pi&gt;Pj&#125;</div><div class="line">　　　　　　1，  对换Pj，Pk，</div><div class="line">　　　　　　2，  将Pj<span class="string">+1</span>…Pk<span class="string">-1</span>PjPk<span class="string">+1</span>…Pn翻转</div><div class="line">         P’= P1P2…Pj<span class="string">-1</span>PkPn…Pk<span class="string">+1</span>PjPk<span class="string">-1</span>…Pj<span class="string">+1</span>即P的下一个</div></pre></td></tr></table></figure>
<p>【例】 如何得到346987521的下一个</p>
<ol>
<li>从尾部往前找第一个P(i-1) &lt; P(i)的位置<br> 3   4   <strong>6</strong> &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1<br>最终找到6是第一个变小的数字，记录下6的位置i-1</li>
<li>从i位置往后找到最后一个大于6的数<br>3 4 6 -&gt; 9 -&gt; 8 -&gt; <strong>7</strong> 5 2 1<br>最终找到7的位置，记录位置为m</li>
<li>交换位置i-1和m的值<br>3 4 <strong>7</strong> 9 8 <strong>6</strong> 5 2 1</li>
<li>倒序i位置后的所有数据<br>3 4 7 <strong>1 2 5 6 8 9</strong><br>则347125689为346987521的下一个排列</li>
</ol>
<p>依照上面的讲述不难将代码写出来，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PermutationList</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> fromIndex, endIndex, changeIndex;</div><div class="line">    Sort(<span class="number">0</span>, length - <span class="number">1</span>);</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 输出一种全排列</span></div><div class="line">        Output();</div><div class="line">        fromIndex = endIndex = length - <span class="number">1</span>;</div><div class="line">        <span class="comment">// 向前查找第一个变小的元素</span></div><div class="line">        <span class="keyword">while</span> (fromIndex &gt; <span class="number">0</span> &amp;&amp; words[fromIndex] &lt; words[fromIndex - <span class="number">1</span>]) --fromIndex;</div><div class="line">        changeIndex = fromIndex;</div><div class="line">        <span class="keyword">if</span> (fromIndex == <span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">        <span class="comment">// 向后查找最后一个大于words[fromIndex-1]的元素</span></div><div class="line">        <span class="keyword">while</span> (changeIndex + <span class="number">1</span> &lt; length &amp;&amp; words[changeIndex + <span class="number">1</span>] &gt; words[fromIndex - <span class="number">1</span>]) ++changeIndex;</div><div class="line">        Swap(fromIndex - <span class="number">1</span>, changeIndex);   <span class="comment">// 交换两个值</span></div><div class="line">        InvertArray(fromIndex, endIndex);   <span class="comment">// 对后面的所有值进行反向处理</span></div><div class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="方法3-递归方法求全排列"><a href="#方法3-递归方法求全排列" class="headerlink" title="方法3 递归方法求全排列"></a>方法3 递归方法求全排列</h1><p>　　递归方法很容易理解：分别将每个位置交换到最前面位，之后全排列剩下的位。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">【例】递归全排列 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></div><div class="line">    <span class="number">1.</span> for循环将每个位置的数据交换到第一位</div><div class="line">  		 swap(<span class="number">1</span>,<span class="number">1</span>~<span class="number">5</span>)</div><div class="line">	<span class="number">2.</span> 按相同的方式全排列剩余的位</div></pre></td></tr></table></figure></p>
<h2 id="递归全排列1"><a href="#递归全排列1" class="headerlink" title="递归全排列1"></a>递归全排列1</h2><p>由于递归方法很容易理解，而且网上也有很多的资料，所以不过多讲述，代码如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></div><div class="line">      <span class="comment"><span class="doctag">///</span> 递归方式生成全排列的方法 3-1</span></div><div class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></div><div class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="fromIndex"&gt;</span>全排列的起始位置<span class="doctag">&lt;/param&gt;</span></span></div><div class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="endIndex"&gt;</span>全排列的终止位置<span class="doctag">&lt;/param&gt;</span></span></div><div class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PermutationList</span>(<span class="params"><span class="keyword">int</span> fromIndex, <span class="keyword">int</span> endIndex</span>)</span></div><div class="line">      &#123;</div><div class="line">          <span class="keyword">if</span> (fromIndex == endIndex)</div><div class="line">              Output();</div><div class="line">          <span class="keyword">else</span></div><div class="line">          &#123;</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> index = fromIndex; index &lt;= endIndex; ++index)</div><div class="line">              &#123;</div><div class="line">                  <span class="comment">//此处排序主要是为了生成字典序全排列，否则递归会打乱字典序</span></div><div class="line">                  sort(fromIndex, endIndex);</div><div class="line">                  Swap(fromIndex, index);</div><div class="line">                  PermutationList(fromIndex + <span class="number">1</span>, endIndex);</div><div class="line">                  Swap(fromIndex, index);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>不过<strong>需要注意,如果不加入第15行的<code>sort(fromIndex, endIndex);</code>那么生成的全排列就是非完全升序的</strong>.</p>
<div align="center"><br><img src="/2016/08/25/字符串全排列/outorder-permutation.jpg" alt="outorder-permutation.jpg" title=""><br></div>

<p>同时可以对进行修改,使其生成的全排列是完全升序的</p>
<h2 id="递归全排列2"><a href="#递归全排列2" class="headerlink" title="递归全排列2"></a>递归全排列2</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"><span class="keyword">void</span> p(<span class="built_in">char</span>* <span class="built_in">str</span>, <span class="built_in">int</span> i, <span class="built_in">int</span> <span class="built_in">size</span>)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//到达字符串末尾则停止并输出 </span></div><div class="line">	<span class="keyword">if</span>(i == <span class="built_in">size</span>)</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; <span class="built_in">str</span> &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; <span class="built_in">size</span>; j++)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//置换; </span></div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k = j; k &gt; i; k--)</div><div class="line">		&#123;</div><div class="line">			swap(<span class="built_in">str</span>[k], <span class="built_in">str</span>[k - <span class="number">1</span>]);</div><div class="line">		&#125;</div><div class="line">		p(<span class="built_in">str</span>, i + <span class="number">1</span>, <span class="built_in">size</span>);</div><div class="line">		<span class="comment">//置换; </span></div><div class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> k = i; k &lt; j; k++)</div><div class="line">		&#123;</div><div class="line">			swap(<span class="built_in">str</span>[k], <span class="built_in">str</span>[k + <span class="number">1</span>]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">int</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="built_in">char</span> <span class="built_in">str</span>[<span class="number">7</span>];</div><div class="line">	cin &gt;&gt; <span class="built_in">str</span>;</div><div class="line">	<span class="built_in">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</div><div class="line">	<span class="comment">//判断字符长度 </span></div><div class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">'\0'</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">size</span> = i;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	p(<span class="built_in">str</span>, <span class="number">0</span>, <span class="built_in">size</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="方法4-递归方法求全排列2"><a href="#方法4-递归方法求全排列2" class="headerlink" title="方法4 递归方法求全排列2"></a>方法4 递归方法求全排列2</h1><p>思路是这样的：我们维护两个序列，一个序列是要进行全排列的序列，我们暂称之为源序列，另一个序列是全排列之后的结果序列，我们称其为结果序列。过程如下：</p>
<ol>
<li>初始时源序列为输入的字符串序列，结果序列为空</li>
<li><p>如果源序列中的元素个数大于1，则对源序列中的每一个元素，进行如下操作：</p>
<ol>
<li>以结果序列+该元素生成新的结果序列</li>
<li>将该元素从源序列中剔除并保持其他元素顺序不变生成新的源序列</li>
</ol>
<p>然后以I产生的结果序列和II产生的源序列为基础递归2）过程</p>
</li>
<li>如果源序列中元素个数不大于1，则打印结果序列+源序列</li>
</ol>
<p>下面给出了该思路的C++实现，参考[1][2]<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> permutation(<span class="keyword">string</span> <span class="built_in">begin</span>, <span class="keyword">string</span> <span class="built_in">end</span>)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> endLength = <span class="built_in">end</span>.<span class="built_in">size</span>(), beginLength = <span class="built_in">begin</span>.<span class="built_in">size</span>();</div><div class="line">	<span class="built_in">if</span>(endLength == <span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; <span class="built_in">begin</span> &lt;&lt; <span class="built_in">end</span> &lt;&lt; endl;</div><div class="line">		<span class="built_in">return</span> ;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">string</span> newEnd;</div><div class="line">	<span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endLength; i++)</div><div class="line">	&#123;</div><div class="line">		newEnd = <span class="built_in">end</span>.substr(<span class="number">0</span>, i) + <span class="built_in">end</span>.substr(i+<span class="number">1</span>);</div><div class="line">		permutation(<span class="built_in">begin</span> + <span class="built_in">end</span>[i], newEnd);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">string</span> str;</div><div class="line">	<span class="keyword">string</span> n = <span class="string">""</span>;</div><div class="line">	cin &gt;&gt; str;</div><div class="line">	permutation(n, str);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<div align="center"><br><img src="/2016/08/25/字符串全排列/inorder-permutation.png" alt="inorder-permutation.png" title=""><br></div>

<p>综上,文章介绍了四种字符串全排列的方法:</p>
<ul>
<li>去重: 方法1,方法2</li>
<li>不去重按序：方法3-2,方法4</li>
<li>不去重不排序：方法3-1</li>
</ul>
<p>参考:</p>
<ol>
<li><a href="http://www.java2s.com/Tutorial/Java/0100__Class-Definition/RecursivemethodtofindallpermutationsofaString.htm" target="_blank" rel="external">Recursive method to find all permutations of a String</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6fb300a30100mvzp.html" target="_blank" rel="external">关于全排列算法的思考</a></li>
<li><a href="http://www.cnblogs.com/pmars/archive/2013/12/04/3458289.html" target="_blank" rel="external">字典序全排列算法研究</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[二分查找]]></title>
      <url>http://wlyPKU.github.io/2016/08/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p> 二分查找算法是在有序数组中用到的较为频繁的一种算法，在未接触二分查找算法时，最通用的一种做法是，对数组进行遍历，跟每个元素进行比较，其时间为O(n).但二分查找算法则更优，因为其查找时间为O(lgn)，譬如数组{1， 2， 3， 4， 5， 6， 7， 8， 9}，查找元素6，用二分查找的算法执行的话，其顺序为：</p>
<ol>
<li>第一步查找中间元素，即5，由于5&lt;6，则6必然在5之后的数组元素中，那么就在{6， 7， 8， 9}中查找,</li>
<li>寻找{6， 7， 8， 9}的中位数，为7,7&gt;6，则6应该在7左边的数组元素中，那么只剩下6，即找到了。</li>
</ol>
<a id="more"></a>
<p>二分查找算法就是不断将数组进行对半分割，每次拿中间元素和goal进行比较。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> findTarget(<span class="keyword">int</span> *<span class="keyword">array</span>, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> target)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">while</span>(<span class="built_in">begin</span> &lt;= <span class="built_in">end</span>)</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">int</span> pMid = <span class="built_in">begin</span> + (<span class="built_in">begin</span> - <span class="built_in">end</span>) / <span class="number">2</span>;</div><div class="line">        <span class="built_in">if</span>(<span class="keyword">array</span>[pMid] == target)</div><div class="line">        &#123;</div><div class="line">        	<span class="built_in">return</span> pMid;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">else</span> <span class="built_in">if</span>(<span class="keyword">array</span>[pMid] &gt; target)</div><div class="line">        &#123;</div><div class="line">        	<span class="built_in">end</span> = pMid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">else</span></div><div class="line">        &#123;</div><div class="line">        	<span class="built_in">begin</span> = pMid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> length, target;</div><div class="line">    cin &gt;&gt; length;</div><div class="line">    <span class="keyword">int</span> <span class="keyword">array</span>[<span class="number">1000</span>];</div><div class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</div><div class="line">    &#123;</div><div class="line">    	cin &gt;&gt; <span class="keyword">array</span>[i];</div><div class="line">    &#125;</div><div class="line">    sort(<span class="keyword">array</span>, length + <span class="keyword">array</span>);</div><div class="line">    cin &gt;&gt; target;</div><div class="line">    cout &lt;&lt; findlastTarget(<span class="keyword">array</span>, <span class="number">0</span>, num - <span class="number">1</span>, target) &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大家对于二分查找并不陌生，一般意义上的二分查找，往往返回给我们的是目标元素在排序数组中出现的一个随机的位置，但是在很多时候，我们却是需要目标元素的第一个和最后一个位置，才有意义。举个例子来说，我们要求得目标元素在排序数组中出现的次数，假如利用一般的方法，逐个比较目标元素和数组元素，时间复杂度<code>O(n)</code>，不能够令我们满意，既然数组是排序的我们很容易想到二分查找，在这里我们能不能使用二分查找的算法呢，答案是肯定的。只要我们能够利用二分查找找到目标元素出现的第一个和最后一个位置，就能够求得它出现的次数。我们如何来求得目标元素出现的第一个和最后一个位置呢，其实很简单，我们只需要对于二分查找的退出条件，做一个简单的设定就能得到我们理想的结果哦！<br>下面我们来看一下代码:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> find1stTarget(<span class="keyword">int</span> *<span class="keyword">array</span>, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> target)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">while</span>(<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">int</span> pMid = (<span class="built_in">begin</span> + <span class="built_in">end</span>) / <span class="number">2</span>;</div><div class="line">        <span class="built_in">if</span>(<span class="keyword">array</span>[pMid] &lt; target)</div><div class="line">        &#123;</div><div class="line">        	<span class="built_in">begin</span> = pMid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">else</span></div><div class="line">        &#123;</div><div class="line">        	<span class="built_in">end</span> = pMid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">if</span>(<span class="keyword">array</span>[<span class="built_in">begin</span>] == target)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">return</span> <span class="built_in">begin</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里跟一般的二分查找的代码相比，仅仅是判断语句上做了一点细微的变化，序列是递增排列的，当中间值小于目标元素的时候，目标元素在序列的右边：begin = pMid + 1;其余的情况目标值在序列的左边：end = pMid；我们要查找的第一个目标元素的位置，一般的情况就是目标元素存在多个情况，由上述的两个判断条件，我们可以知道，如果查找到了目标元素，并且该目标元素不是第一个的时候，此时继续执行向左查找，而不终止，直到找到第一个元素为止。<br>同理，寻找最后一个元素也是:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> findlastTarget(<span class="keyword">int</span> *<span class="keyword">array</span>, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> target)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">while</span>(<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</div><div class="line">	&#123;</div><div class="line">        <span class="keyword">int</span> pMid = (<span class="built_in">begin</span> + <span class="built_in">end</span> + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//保证取到中间靠后的位置</span></div><div class="line">        <span class="built_in">if</span>(<span class="keyword">array</span>[pMid] &gt; target)</div><div class="line">		&#123;</div><div class="line">            <span class="built_in">end</span> = pMid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">		<span class="built_in">else</span></div><div class="line">		&#123;</div><div class="line">            <span class="built_in">begin</span> = pMid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">if</span>(<span class="keyword">array</span>[<span class="built_in">begin</span>] == target)</div><div class="line">    &#123;</div><div class="line">    	<span class="built_in">return</span> <span class="built_in">begin</span>;</div><div class="line">	&#125;</div><div class="line">    <span class="built_in">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大家可以看出，跟我们取第一个元素时候的判断条件恰好相反，而两种情况处理的方式我们可以归结为以下两句话：</p>
<ol>
<li><p><strong>当我们要找到目标元素出现的第一个位置时候：当中间值大于等于目标元素的时候，我们要保留当前中间值的位置，并且在左边继续查找。</strong><br>这句话用条件语句表述就是：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">array</span>[pMid] &lt; target)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">begin</span> = pMid + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>当我们要找目标元素出现的最后一个位置的时候：当中间值小于等于目标元素的时候，我们要保留中间值的位置，并且在右边继续查找。</strong></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">array</span>[pMid] &gt; target)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">end</span> = pMid - <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>同时注意为了取到稍后的元素,需要执行<code>int pMid = (begin + end + 1) / 2;</code>,保证取到中间靠后的位置.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git && SVN 安装]]></title>
      <url>http://wlyPKU.github.io/2016/08/23/Git-SVN-%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>为了利于版本控制与合作,可以选择在自己的机器上搭建Git和SVN的版本控制,本文是在服务器上配置Git服务器与SVN服务器、http访问的简单教程。<br><a id="more"></a></p>
<h1 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h1><p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。<br>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。</p>
<h2 id="安装及初始化"><a href="#安装及初始化" class="headerlink" title="安装及初始化"></a>安装及初始化</h2><p>假设你已经有sudo权限的用户账号，下面开始安装。</p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="keyword">get</span> install git</div></pre></td></tr></table></figure>
<h3 id="创建一个git用户，用来运行git服务"><a href="#创建一个git用户，用来运行git服务" class="headerlink" title="创建一个git用户，用来运行git服务"></a>创建一个git用户，用来运行git服务</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">sudo</span> <span class="keyword">adduser </span>git</div></pre></td></tr></table></figure>
<h3 id="创建证书登录"><a href="#创建证书登录" class="headerlink" title="创建证书登录"></a>创建证书登录</h3><pre><code>收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。
</code></pre><p>使用命令：<code>ssh-keygen –t rsa</code>生成密钥，如下图<br><img src="/2016/08/23/Git-SVN-安装/rsa.jpg" alt="rsa.jpg" title=""><br>完成之后，在.ssh目录下，我们可以看到id_rsa和id_rsa.pub文件，id_rsa.pub为公钥.我们首先查看/home/git/.ssh目录下是否存在authorized_kesys文件，<br>如果没有，可以通过<code>touch authorized_keys</code>创建此文件。<br>Authorized_keys创建完成后，将生成的公钥id_rsa.pub的内容追 加到authroized_keys中,注意是<strong>追加</strong>到此文件中，可以使用命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat <span class="regexp">/home/gi</span>t<span class="regexp">/id_rsa.pub&gt;&gt;/</span>home<span class="regexp">/git/</span>.ssh<span class="regexp">/authorized_keys</span></div></pre></td></tr></table></figure></p>
<h2 id="创建repository及设置权限"><a href="#创建repository及设置权限" class="headerlink" title="创建repository及设置权限"></a>创建repository及设置权限</h2><h3 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h3><p>先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo git init <span class="comment">--bare sample.git</span></div></pre></td></tr></table></figure></p>
<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">chown</span> <span class="selector-tag">-R</span> <span class="selector-tag">git</span><span class="selector-pseudo">:git</span> <span class="selector-tag">sample</span><span class="selector-class">.git</span></div></pre></td></tr></table></figure></p>
<h3 id="禁用shell登录"><a href="#禁用shell登录" class="headerlink" title="禁用shell登录"></a>禁用shell登录</h3><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：<code>git:x:1001:1001:,,,:/home/git:/bin/bash</code><br>改为：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git:</span><span class="symbol">x:</span><span class="number">1001</span><span class="symbol">:</span><span class="number">1001</span><span class="symbol">:</span>,,,<span class="symbol">:/home/git</span><span class="symbol">:/usr/bin/git-shell</span></div></pre></td></tr></table></figure></p>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone git<span class="variable">@server:</span>/srv/sample.git</div><div class="line">Cloning into <span class="string">'sample'</span>...</div><div class="line"><span class="attribute">warning</span>: You appear to have cloned an empty repository.</div></pre></td></tr></table></figure></p>
<h2 id="常见git指令"><a href="#常见git指令" class="headerlink" title="常见git指令"></a>常见git指令</h2><p>通过以上的步骤我们就完成了git服务器的搭建，完成搭建后，我们需要了解一下与git服务器交互过程中所用到命令。主要命令有 git clone、git remote、git fetch、git pull、git push等，下面我们逐一了解</p>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>此命令是我们和远程仓库交互的第一步，通过此命令，我们可以将远程版本库克隆到本地.<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#本地库名称可以省略，省略后在本地会生成一个和远程版本库名字相同的目录。</span></div><div class="line">git <span class="keyword">clone</span> <span class="title">版本库的网址 本地库名称</span></div></pre></td></tr></table></figure></p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>此命令用于管理远程主机名，此命令在没有参数的情况下可以列出所有主机名。<br>显示origin是在使用clone命令，克隆远程版本库时Git自动为远程主机命名。<br>通过命令 git remote –v，可查看版本库的网址。</p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>此命令可以将远程版本库的更新，更新到本地库。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git</span> fetch 主机名字</div></pre></td></tr></table></figure></p>
<p>在默认情况下，git fetch origin将会更新远程主机origin上的所有分支，如果只想更新某个分支，则在主机名origin后面加分支名。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch origin <span class="literal">master</span></div></pre></td></tr></table></figure></p>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>此命令用于将本地分支的更新推送到远程主机。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> <span class="keyword">push </span>远程主机名 本地分支名：远程分支名</div></pre></td></tr></table></figure></p>
<p>如果省略远程分支名，则表示将本地分支推送与存在最终关系的远程分支，如果远程分支不存在，则会被新建。<br>如：<code>git push origin master</code>,表示将本地master分支推送到origin主机的master分支上。<br>如果省略本地分子名，则表示要删除远程主机中分支，如<code>git push origin : master</code>,则表示删除origin主机中master分支</p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>此命令用于获取远程分支中更新。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git pull 远程主机 远程分支：本地分支</div><div class="line">#如：git pull <span class="built_in">origin</span> master:master,表示将远程主机<span class="built_in">origin</span>中的master分支跟新到本地分支master</div></pre></td></tr></table></figure></p>
<p>参考:</p>
<ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="external">搭建Git服务器</a></li>
<li><a href="http://developer.51cto.com/art/201507/483448.htm" target="_blank" rel="external">Git服务器搭建全过程分步详解</a></li>
</ul>
<hr>
<h1 id="SVN安装"><a href="#SVN安装" class="headerlink" title="SVN安装"></a>SVN安装</h1><h2 id="安装SVN"><a href="#安装SVN" class="headerlink" title="安装SVN"></a>安装SVN</h2><h3 id="更新apt-get源-安装时开始就是没更新源-版本不一致弄了好久"><a href="#更新apt-get源-安装时开始就是没更新源-版本不一致弄了好久" class="headerlink" title="更新apt-get源(安装时开始就是没更新源,版本不一致弄了好久)"></a>更新apt-get源(安装时开始就是没更新源,版本不一致弄了好久)</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></div></pre></td></tr></table></figure>
<h3 id="安装所需的文件"><a href="#安装所需的文件" class="headerlink" title="安装所需的文件"></a>安装所需的文件</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-<span class="keyword">get</span> install subversion libapache2-<span class="keyword">mod</span>-svn libapache2-svn apache2</div></pre></td></tr></table></figure>
<h3 id="创建用户组"><a href="#创建用户组" class="headerlink" title="创建用户组"></a>创建用户组</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">groupadd subversion</span></div></pre></td></tr></table></figure>
<h3 id="创建一个svn实例"><a href="#创建一个svn实例" class="headerlink" title="创建一个svn实例"></a>创建一个svn实例</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> /<span class="built_in">home</span>/svn/ </div><div class="line">svnadmin create example</div></pre></td></tr></table></figure>
<h3 id="修改-etc-apache2-mods-enabled-dav-svn-conf"><a href="#修改-etc-apache2-mods-enabled-dav-svn-conf" class="headerlink" title="修改/etc/apache2/mods-enabled/dav_svn.conf:"></a>修改/etc/apache2/mods-enabled/dav_svn.conf:</h3><p>去掉下面行的注释。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;Location /svn&gt;</span>   （apache下的位置）</div><div class="line">  DAV svn </div><div class="line">  SVNParentPath <span class="meta-keyword">/home/</span>svn   （如果有多个库，使用该选项）</div><div class="line">  SVNListParentPath on     （打开这个选项可以列出ParentPath下面的所有库）</div><div class="line">  AuthType Basic   （认证类型为基本认证 ）</div><div class="line">  AuthName <span class="string">"Subversion Repository"</span>（认证名称,将在IE界面弹出一个对话框,其标题）</div><div class="line">  AuthUserFile <span class="meta-keyword">/etc/</span>apache2/dav_svn.passwd    （认证密码文件）</div><div class="line">  <span class="meta"># AuthzSVNAcessFile /etc/apache2/dav_svn.authz     （目录权限文件）</span></div><div class="line"></div><div class="line">  Require valid-user    （要求验证用户，即不能匿名访问）</div><div class="line"><span class="params">&lt;/Location&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h2><p>下为加入新的SVN时需要执行的步骤:<br>目标:新加一个名为zhangzhipeng的版本库，并将用户名zhangzhipeng加入到svn用户中</p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /<span class="built_in">home</span>/svn</div><div class="line">sudo <span class="built_in">mkdir</span> zhangzhipeng</div></pre></td></tr></table></figure>
<h3 id="将用户名加入subversion组中"><a href="#将用户名加入subversion组中" class="headerlink" title="将用户名加入subversion组中"></a>将用户名加入subversion组中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">groups zhangzhipeng    <span class="comment"># 先查看是否已在组中</span></div><div class="line">zhangzhipeng : zhangzhipeng</div><div class="line">sudo usermod -G subversion <span class="_">-a</span> zhangzhipeng</div><div class="line">groups zhangzhipeng    <span class="comment"># 现在可以看到多加了个组别</span></div></pre></td></tr></table></figure>
<h3 id="为刚才所建目录新建版本库，并添加对应权限"><a href="#为刚才所建目录新建版本库，并添加对应权限" class="headerlink" title="为刚才所建目录新建版本库，并添加对应权限"></a>为刚才所建目录新建版本库，并添加对应权限</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo svnadmin create /home/svn/zhangzhipeng</div><div class="line">sudo <span class="keyword">chown</span> -R www-data:subversion zhangzhipeng    <span class="comment"># 允许apache对该目录作修改</span></div><div class="line">sudo <span class="keyword">chmod</span> -R g+ws zhangzhipeng</div></pre></td></tr></table></figure>
<h3 id="为新加的svn账号zhangzhipeng设置密码"><a href="#为新加的svn账号zhangzhipeng设置密码" class="headerlink" title="为新加的svn账号zhangzhipeng设置密码"></a>为新加的svn账号zhangzhipeng设置密码</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#后面再添加用户的时候(添加第二个用户及以后时)去掉-c选项。</span></div><div class="line">sudo htpasswd -c <span class="regexp">/etc/</span>aoache2<span class="regexp">/dav_svn.passwd zhangzhipeng</span></div></pre></td></tr></table></figure>
<h3 id="重启apache使设置生效"><a href="#重启apache使设置生效" class="headerlink" title="重启apache使设置生效"></a>重启apache使设置生效</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service apache2 <span class="built_in">restart</span></div></pre></td></tr></table></figure>
<p>即可在<a href="http://localhost/svn/zhangzhipeng处访问。" target="_blank" rel="external">http://localhost/svn/zhangzhipeng处访问。</a></p>
<hr>
<p>同时，如果需要在shell里进行svn的版本控制，需要对svn的repository进行权限设置：<br>具体可参考:</p>
<ul>
<li><a href="http://svnbook.red-bean.com/en/1.5/svn-book.pdf" target="_blank" rel="external">svn-book</a></li>
<li><a href="http://blog.chinaunix.net/uid-10167808-id-25994.html" target="_blank" rel="external"> SVN服务器之用户权限配置——authz文件 </a></li>
</ul>
<p>svn命令可参考<a href="http://www.tuicool.com/articles/M7FJbiq" target="_blank" rel="external">svn常用命令详解</a><br>安装过程也可参考</p>
<ul>
<li><a href="https://help.ubuntu.com/lts/serverguide/subversion.html" target="_blank" rel="external">Subversion官方指南</a></li>
<li><a href="http://www.blogjava.net/jasmine214--love/archive/2010/09/26/332989.html" target="_blank" rel="external">通过Apache来访问SVN的配置方法</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Stunnel+Squid访问Facebook]]></title>
      <url>http://wlyPKU.github.io/2016/08/23/Stunnel-Squid%E8%AE%BF%E9%97%AEFacebook/</url>
      <content type="html"><![CDATA[<p>由于访问Google、Facebook、Dropbox等网站的途径被封锁，实验室需要一个能够直连外网的代理Proxy。因此，配置了stunnel+squid的代理。需要一台可以连接外网的VPS和能够连接VPS的实验室服务器。<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">       <span class="comment">主机</span>                <span class="comment">实验室服务器</span>                      <span class="comment">VPS</span></div><div class="line"><span class="comment">路径</span>     <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="title">[</span><span class="comment">stunnel客户端</span><span class="title">]</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="title">[</span><span class="comment">stunnel服务端</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">squid</span><span class="title">]</span></div><div class="line"><span class="comment">端口</span>                 <span class="comment">8080</span>                              <span class="comment">443</span>             <span class="comment">3128</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>stunnel的优点和shadowsocks一样,但是却比shadowsocks更安全,stunnel可以来ssl证书,比shadowsocks的密码认证更安全,也能有效的避免中间人攻击,把你的shadowsocks数据拦截下,然后暴力破解应该是易如反掌.</p>
<h1 id="squid安装"><a href="#squid安装" class="headerlink" title="squid安装"></a>squid安装</h1><p>单独的stunnel是无法使用的,必须配合http代理,如squid<br>ubuntu linux服务器端安装:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="keyword">get</span> install squid3 stunnel4</div></pre></td></tr></table></figure></p>
<p>squid默认代理端口号3128,可自行修改,默认此代理只能本地有权限访问<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">grep</span> --color <span class="string">'http_port'</span> <span class="regexp">/etc/</span>squid3<span class="regexp">/squid.conf</span></div></pre></td></tr></table></figure></p>
<h1 id="stunnel的证书和服务器端配置"><a href="#stunnel的证书和服务器端配置" class="headerlink" title="stunnel的证书和服务器端配置"></a>stunnel的证书和服务器端配置</h1><h2 id="生成自定义证书"><a href="#生成自定义证书" class="headerlink" title="生成自定义证书:"></a>生成自定义证书:</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sudo -s </div><div class="line">cd /etc/stunnel</div><div class="line"><span class="selector-id">#stunnel</span>.pem是生成的证书文件名字</div><div class="line">openssl req -new -x509 -days <span class="number">365</span> -nodes -out stunnel<span class="selector-class">.pem</span> -keyout stunnel<span class="selector-class">.pem</span></div><div class="line">#生成证书的过程中需要填写一些国家城市公司等信息,全部随便填写即可</div><div class="line">#下面的命令执行的时间叫长 耐心等待</div><div class="line">openssl gendh <span class="number">2048</span> &gt;&gt; stunnel<span class="selector-class">.pem</span></div><div class="line">#出现unable to write <span class="string">'random state'</span>错误的请执行 rm ~/<span class="selector-class">.rnd</span></div><div class="line">#查看生成的证书相关信息</div><div class="line">openssl x509 -subject -dates -fingerprint -<span class="keyword">in</span> stunnel.pem</div></pre></td></tr></table></figure>
<h2 id="stunnel服务器对客户端证书的验证-stunnel的配置"><a href="#stunnel服务器对客户端证书的验证-stunnel的配置" class="headerlink" title="stunnel服务器对客户端证书的验证,stunnel的配置"></a>stunnel服务器对客户端证书的验证,stunnel的配置</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#查看stunnel默认配置,下面命令结果的最后一行是默认配置</span></div><div class="line">cat <span class="meta-keyword">/etc/</span>stunnel/README</div><div class="line"><span class="meta">#添加默认配置</span></div><div class="line">sudo cp <span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/doc/</span>stunnel4<span class="meta-keyword">/examples/</span>stunnel.conf-sample <span class="meta-keyword">/etc/</span>stunnel/stunnel.conf</div></pre></td></tr></table></figure>
<ol>
<li>编辑/etc/stunnel/stunnel.conf文件找到 chroot = /var/lib/stunnel4/这一行,假如有注释把注释去掉</li>
<li>开启调试模式,/etc/stunnel/stunnel.conf文件找到 debug = 7去掉注释,添加foreground = yes到debug = 7下面</li>
</ol>
<h2 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /var/<span class="class"><span class="keyword">lib</span>/<span class="title">stunnel4</span>/</span></div><div class="line">sudo mkdir certs</div><div class="line">cp /etc/stunnel/stunnel.pem certs/<span class="string">`openssl x509 -hash -noout -in /etc/stunnel/stunnel.pem`</span>.</div></pre></td></tr></table></figure>
<p>接下来编辑/etc/stunnel/stunnel.conf</p>
<ol>
<li>找到cert = /etc/stunnel/mail.pem修改成cert = /etc/stunnel/stunnel.pem,设置cert证书路径</li>
<li>找到verify = 2去掉注释改成verify = 3,开启证书有效性验证</li>
<li>找到CApath = /certs有注释去掉注释,这个目录是建立在chroot = /var/lib/stunnel4/基础上,实际就是/var/lib/stunnel4/certs目录,也就是验证证书的目录</li>
<li>找到CAfile = /etc/stunnel/certs.pem,有注释去掉注释,并改成之前生成自定义证书的目录:CAfile = /etc/stunnel/stunnel.pem</li>
</ol>
<p>关于证书的全部设置结束</p>
<h2 id="配置stunnel的端口和squid的http代理"><a href="#配置stunnel的端口和squid的http代理" class="headerlink" title="配置stunnel的端口和squid的http代理"></a>配置stunnel的端口和squid的http代理<br></h2><p>编辑/etc/stunnel/stunnel.conf,找到<br><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">; <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>*</div><div class="line">; <span class="bullet">* Service definitions (remove all services for inetd mode)               *</span></div><div class="line">; <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>*</div></pre></td></tr></table></figure></p>
<p>从这里一直文件结尾,全部删除,添加如下内容:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">[https]</span></div><div class="line"><span class="attr">accept</span>  = <span class="number">443</span></div><div class="line"><span class="attr">connect</span> = <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">3128</span></div></pre></td></tr></table></figure></p>
<p>简单解释:[https]这个https可以随便写, 3128是squid的http代理默认端口,stunnel将使用这个代理,也就是127.0.0.1:3128. connect部分是stunnel客户端将要连接的代理服务器地址和端口号,端口号443可自信随意修改.</p>
<p>stunnel服务器端的所有配置完毕,重新启动:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo killall stunnel4</div><div class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/stunnel4 start</span></div></pre></td></tr></table></figure></p>
<h1 id="Stunnel客户端配置"><a href="#Stunnel客户端配置" class="headerlink" title="Stunnel客户端配置"></a>Stunnel客户端配置</h1><p>最后是配置stunnel客户端:本人也是ubuntu系统 ubuntu desktop</p>
<h2 id="安装stunnel"><a href="#安装stunnel" class="headerlink" title="安装stunnel"></a>安装stunnel</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="keyword">get</span> install stunnel4</div></pre></td></tr></table></figure>
<h2 id="添加默认配置文件"><a href="#添加默认配置文件" class="headerlink" title="添加默认配置文件"></a>添加默认配置文件</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp <span class="regexp">/usr/</span>share<span class="regexp">/doc/</span>stunnel4<span class="regexp">/examples/</span>stunnel.conf-sample <span class="regexp">/etc/</span>stunnel<span class="regexp">/stunnel.conf</span></div></pre></td></tr></table></figure>
<p>开启stunnel调试模式,参考上面stunnel服务器端配置</p>
<h2 id="配置证书-1"><a href="#配置证书-1" class="headerlink" title="配置证书"></a>配置证书</h2><ol>
<li><p>把上面stunnel服务器端生成的证书,复制一份到本地<br>可以这样</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp 你的用户名@服务器地址<span class="symbol">:/etc/stunnel/stunnel</span>.pem /etc/stunnel/stunnel.pem</div></pre></td></tr></table></figure>
</li>
<li><p>编辑本地/etc/stunnel/stunnel.conf文件,设置证书路径:<br>找到<code>cert = /etc/stunnel/mail.pem</code>修改成<code>cert = /etc/stunnel/stunnel.pem</code></p>
</li>
<li>找到<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">; <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>*</div><div class="line">; <span class="bullet">* Service definitions (remove all services for inetd mode)               *</span></div><div class="line">; <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span>*</div></pre></td></tr></table></figure>
</li>
</ol>
<p>一直到文件结尾全部删除,添加如下内容:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">[https]</span></div><div class="line"><span class="attr">client</span> = <span class="literal">yes</span></div><div class="line"><span class="attr">accept</span>  = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span></div><div class="line"><span class="attr">connect</span> = stunnel服务器地址:<span class="number">443</span></div></pre></td></tr></table></figure></p>
<p>简单解释:client = yes表示stunnel是运行的是客户端模式,默认没有代表服务器模式<br>accept  = 127.0.0.1:8080当然就是浏览器需要设置的http代理端口了<br>connect = stunnel服务器地址:443,请自行修改成你的服务器地址和上面设置的端口号44</p>
<h2 id="重启stunnel客户端"><a href="#重启stunnel客户端" class="headerlink" title="重启stunnel客户端"></a>重启stunnel客户端</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo killall stunnel4</div><div class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/stunnel4 start</span></div></pre></td></tr></table></figure>
<p>假如所有一切运行正常,然后可以关闭调试模式.注释 foreground = yes 一行<br>ubuntu命令行测试非常简单:本地终端执行<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export http_proxy=<span class="string">'127.0.0.1:8080'</span></div><div class="line">wget www<span class="selector-class">.bing</span><span class="selector-class">.com</span></div></pre></td></tr></table></figure></p>
<p>若有失败错误,请自行查看调试信息!!</p>
<p>开机自启动可参考:/etc/stunnel/README文件所描述的,把stunnel服务器端和客户端的/etc/default/stunnel4文件里面的ENABLED设置成1</p>
<p>参考：<a href="http://www.myexception.cn/linux-unix/1713467.html" target="_blank" rel="external">vps的ubuntu linux下轻便搭建stunnel通过https代理上外网</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一阶机器学习优化算法Paper汇总]]></title>
      <url>http://wlyPKU.github.io/2016/08/23/%E4%B8%80%E9%98%B6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>对一阶机器学习优化算法ADMM、Coordinate Descent和Gradient Descent的paper加以简单整理。<br><a id="more"></a></p>
<h1 id="ADMM"><a href="#ADMM" class="headerlink" title="ADMM"></a>ADMM</h1><ul>
<li><p><a href="https://web.stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf" target="_blank" rel="external">Distributed Optimization and Statistical Learning via the Alternating Direction Method of Multipliers</a></p>
</li>
<li><p><a href="https://web.stanford.edu/~boyd/papers/pdf/admm_slides.pdf" target="_blank" rel="external">Alternating Direction Method of Multipliers (PPT)</a></p>
</li>
<li><p><a href="http://www.simonlucey.com/lasso-using-admm/" target="_blank" rel="external">LASSO using ADMM</a></p>
</li>
<li><p><a href="http://users.ece.gatech.edu/~justin/CVXOPT-Spring-2015/resources/14-notes-admm.pdf" target="_blank" rel="external">Alternating direction method of multipliers</a></p>
</li>
<li><p><a href="https://web.stanford.edu/~boyd/papers/admm/logreg-l1/logreg.html" target="_blank" rel="external">L1 logistic regression ADMM demo</a></p>
</li>
<li><p><a href="http://mullover.me/2016/01/19/admm-for-distributed-statistical-learning/" target="_blank" rel="external"><strong>用ADMM实现统计学习问题的分布式计算</strong></a></p>
</li>
<li><p><a href="http://joegaotao.github.io/cn/2014/02/admm/" target="_blank" rel="external"><strong>分布式计算、统计学习与ADMM算法</strong></a></p>
</li>
</ul>
<h1 id="Coordinate-Descent"><a href="#Coordinate-Descent" class="headerlink" title="Coordinate Descent"></a>Coordinate Descent</h1><ul>
<li><p><a href="http://www.slideshare.net/sanghyukchun/131121-2-coordinate-descent-method" target="_blank" rel="external">Coordinate Descent method(PPT)</a></p>
</li>
<li><p><a href="https://www.cs.cmu.edu/~ggordon/10725-F12/slides/25-coord-desc.pdf" target="_blank" rel="external">Coordinate descent(PPT)</a></p>
</li>
<li><p><a href="http://www.jmlr.org/papers/volume13/yuan12a/yuan12a.pdf" target="_blank" rel="external">An Improved GLMNET for L1-regularized Logistic Regression</a></p>
</li>
<li><p><a href="http://www.optimization-online.org/DB_FILE/2014/12/4679.pdf" target="_blank" rel="external">Coordinate Descent Algorithms</a></p>
</li>
<li><p><a href="http://www.csie.ntu.edu.tw/~cjlin/papers/l1.pdf" target="_blank" rel="external"><strong>A Comparison of Optimization Methods and Software for Large-scale L1-regularized Linear Classification
</strong></a></p>
</li>
<li><p><a href="https://arxiv.org/pdf/0803.3876.pdf" target="_blank" rel="external">COORDINATE DESCENT ALGORITHMS FOR LASSO PENALIZED REGRESSION</a></p>
</li>
<li><p><a href="https://github.com/acharuva/svm_cd/blob/master/svm_cd.py" target="_blank" rel="external">SVM Coordinate demo</a></p>
</li>
</ul>
<p>parallel</p>
<ul>
<li><a href="https://arxiv.org/pdf/1105.5379v1.pdf" target="_blank" rel="external">Parallel Coordinate Descent for L1-Regularized Loss Minimization</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~cjlin/papers/multicore_cddual.pdf" target="_blank" rel="external">Parallel Dual Coordinate Descent Method for Large-scale Linear Classification in Multi-core Environments(SVM parallel)</a></li>
</ul>
<h1 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h1><ul>
<li><p><a href="http://www.cs.rpi.edu/~magdon/courses/LFD-Slides/SlidesLect09.pdf" target="_blank" rel="external">Logistic Regression and Gradient Descent(PPT)</a></p>
</li>
<li><p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2012/01/tricks-2012.pdf" target="_blank" rel="external"><strong>Stochastic Gradient Descent Tricks</strong></a></p>
</li>
</ul>
<p>variants</p>
<ul>
<li><a href="http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf" target="_blank" rel="external">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a></li>
<li><a href="https://arxiv.org/pdf/1212.5701v1.pdf" target="_blank" rel="external">ADADELTA: AN ADAPTIVE LEARNING RATE METHOD</a></li>
<li><a href="https://arxiv.org/pdf/1412.6980v8.pdf" target="_blank" rel="external">ADAM: A METHOD FOR STOCHASTIC OPTIMIZATION</a></li>
<li><a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="external">RMSprop(ppt)</a></li>
<li><a href="https://arxiv.org/pdf/1312.6055v3.pdf" target="_blank" rel="external">Unit Tests for Stochastic Optimization</a><br>parallel</li>
<li><a href="https://people.eecs.berkeley.edu/~brecht/papers/hogwildTR.pdf" target="_blank" rel="external">Hogwild!: A Lock-Free Approach to Parallelizing Stochastic Gradient Descent</a></li>
<li><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/43138.pdf" target="_blank" rel="external">Delay-Tolerant Algorithms for Asynchronous Distributed Online Learning</a></li>
<li><a href="https://papers.nips.cc/paper/4687-large-scale-distributed-deep-networks.pdf" target="_blank" rel="external">Large Scale Distributed Deep Networks(Downpour SGD)</a></li>
<li><p><a href="https://arxiv.org/pdf/1412.6651v8.pdf" target="_blank" rel="external">Deep learning with Elastic Averaging SGD</a></p>
</li>
<li><p><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="external"><strong>An overview of gradient descent optimization algorithms</strong></a></p>
</li>
</ul>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul>
<li><a href="http://mlss.tuebingen.mpg.de/2013/wright_slides.pdf" target="_blank" rel="external"><strong>Optimization (and Learning)</strong></a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用GitHub Pages和Hexo快速搭建个人博客]]></title>
      <url>http://wlyPKU.github.io/2016/08/23/%E5%88%A9%E7%94%A8GitHub-Pages%E5%92%8CHexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><a href="http://hexo.io" target="_blank" rel="external">hexo</a>是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在github和Heroku上。作者是来自台湾的@tommy351。本文是利用Github和Hexo搭建博客的教程。</p>
<p><div align="center"><br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/hexo.png" alt="hexo.png" title=""><br></div><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>“工欲善其事，必先利其器”，在搭建个人博客的过程中，我深刻体会到这句话的含义。虽然早就决定了要搭建个人博客，但是我并没有草草动手，而是提前做了大量的调研工作，包括采用哪种博客系统、选择哪种主题、怎么购买并绑定个性域名等等。事实证明，正因为前期的充分准备，搭建过程才能按部就班地进行。下面先介绍为何选择GitHub Pages和Hexo来搭建博客，然后介绍搭建博客的详细过程。这篇文章可能长的让人想哭，但如果你坚持看完了，肯定会有收获的。此外，本教程不仅面向计算机专业的同学，任何想搭建个人独立博客的同学，都可以来看看。</p>
<h1 id="why-GitHub-Pages-and-Hexo"><a href="#why-GitHub-Pages-and-Hexo" class="headerlink" title="why GitHub Pages and Hexo"></a>why GitHub Pages and Hexo</h1><p>之前在关于我里面提到过，搭建博客会有三个阶段，我选择的是第三种方法。因为GitHub的存在，我们得以简单快速地搭建个人博客。</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>GitHub，是一个代码托管网站和社交编程网站。这里聚集了世界上各路技术牛叉的大牛，和最优秀的代码库。把你的博客托管在这里，还有什么不放心的呢O(∩_∩)O。</p>
<h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>GitHub Pages，是用来托管GitHub上静态网页的免费站点，那GitHub Pages具体有哪些功能呢：</p>
<ul>
<li><p>有300M免费空间，资料自己管理，保存可靠；</p>
</li>
<li><p>享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；</p>
</li>
<li><p>可以使用很多现成的博客框架，搭建过程简单快速。</p>
</li>
</ul>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo是一个简单、快速、强大的静态博客框架,出自台湾大学生tommy351之手。我也看过使用Jekyll、Octopress搭建个人博客的过程，确实要繁琐许多。相比之下Hexo更轻便更快捷，下面是Hexo官网强调Hexo的四大特点：</p>
<ul>
<li><p>极速生成静态页面</p>
</li>
<li><p>支持Markdown</p>
</li>
<li><p>一键部署博客</p>
</li>
<li><p>丰富的插件支持</p>
</li>
</ul>
<p>相信大家对GitHub Pages和Hexo有了一定的了解，下面进入正题。</p>
<h1 id="使用GitHub-Pages建立博客站点"><a href="#使用GitHub-Pages建立博客站点" class="headerlink" title="使用GitHub Pages建立博客站点"></a>使用GitHub Pages建立博客站点</h1><h2 id="注册GitHub"><a href="#注册GitHub" class="headerlink" title="注册GitHub"></a>注册GitHub</h2><p>访问GitHub,注册十分简单，一定要记住注册时使用的邮箱，因为 GitHub 上很多通知都是通过邮箱的。如下图所示：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogsignupGithub.png" alt="blogsignupGithub.png" title=""><br>申请成功后，在GitHub官网上登录，并验证邮箱即可。</p>
<h2 id="在GitHub上建立仓库"><a href="#在GitHub上建立仓库" class="headerlink" title="在GitHub上建立仓库"></a>在GitHub上建立仓库</h2><p>与 GitHub 建立好连接之后，就可以方便的使用它提供的 Pages 服务，GitHub Pages 分两种，一种是用你的GitHub用户名建立的username.github.io这样的用户&amp;组织站点，另一种是依附项目的Pages。</p>
<p>想建立个人博客是用的第一种，形如username.github.io这样的可访问的站点，每个用户名下面只能建立一个。如下图所示：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogcreateRepo1.png" alt="blogcreateRepo1.png" title=""></p>
<img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogcreateRepo2.png" alt="blogcreateRepo2.png" title="">
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>依次下载并安装下面两个软件，一直点击下一步即可：</p>
<ul>
<li><p><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></p>
</li>
<li><p><a href="https://desktop.github.com/" target="_blank" rel="external">GitHub for Windows</a></p>
</li>
</ul>
<h2 id="使用GitHub-for-Windows登录GitHub"><a href="#使用GitHub-for-Windows登录GitHub" class="headerlink" title="使用GitHub for Windows登录GitHub"></a>使用GitHub for Windows登录GitHub</h2><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogsignin1.png" alt="blogsignin1.png" title="">
<img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogsignin2.png" alt="blogsignin2.png" title="">
<img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogsignin3.png" alt="blogsignin3.png" title="">
<h2 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h2><p>我们如何让本地git项目与远程的GitHub建立联系呢？用SSH key。在桌面或开始菜单中找到 Git Shell，打开后输入以下命令：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-T</span> <span class="selector-tag">git</span>@<span class="keyword">github</span>.<span class="keyword">com</span></div></pre></td></tr></table></figure></p>
<p>如图：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogssh1.png" alt="blogssh1.png" title=""></p>
<p>如果是下面之类的反馈（或者显示 Hi xxx）：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'github.com (207.97.227.239)' can't be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)?</span></div></pre></td></tr></table></figure>
<p>不用紧张，输入 yes 之后,看到下图的结果，就配置成功了：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogssh2.jpg" alt="blogssh2.jpg" title=""></p>
<h1 id="使用Hexo创建博客框架"><a href="#使用Hexo创建博客框架" class="headerlink" title="使用Hexo创建博客框架"></a>使用Hexo创建博客框架</h1><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>打开 Git Shell，启动后依次输入以下命令：<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cd</span> /</div><div class="line">npm config <span class="keyword">set</span> <span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npm.taobao.org/</div><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure></p>
<p>如图：<br></p>
<h2 id="Hexo部署"><a href="#Hexo部署" class="headerlink" title="Hexo部署"></a>Hexo部署</h2><p>Hexo的部署可采用如下方法，输入命令： hexo init [文件名]。</p>
<p>打开Git Shell，启动后依次输入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /</div><div class="line">hexo init Hexo</div></pre></td></tr></table></figure></p>
<p>回车后出现该提示则表示正确：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/bloghexo2.png" alt="bloghexo2.png" title=""></p>
<p>这时会发现 C盘根目录下（或是 Git Shell 里指定的目录下）会多出一个文件夹，名为 Hexo。再输入以下命令，安装依赖文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> Hexo</div><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>回车后出现该提示则表示正确：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/bloghexo3.jpg" alt="bloghexo3.jpg" title=""></p>
<p>部署成功之后，Hexo 会自动在目标文件夹建立博客网站所需要的所有文件。此时可以通过输入以下命令在本地进行预览（在刚才创建的文件夹里）：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">generate</span> </div><div class="line">hexo server</div></pre></td></tr></table></figure></p>
<p>系统可能会出现提示，请点击允许。如下图所示则表示正确：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/bloghexo4.jpg" alt="bloghexo4.jpg" title=""></p>
<p>此时打开浏览器，在浏览器地址栏输入 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> （默认端口为4000）, 便可以看到最原始的博客了。以后发表博文想先预览，也可以通过 hexo server 在本地先跑起来，看看效果。(我在进行这步的时候由于端口号冲突始终没能成功显示，修改端口号也没用，所以最后直接发布到博客预览)。</p>
<p>效果如下图所示：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/bloghexo5.png" alt="bloghexo5.png" title=""></p>
<p>恭喜，到目前为止个人博客的雏形已经有了。</p>
<p>在 Git Shell 中按 Ctrl + C 并输入 y 可以停止该服务。</p>
<h1 id="将本地文件部署到-GitHub"><a href="#将本地文件部署到-GitHub" class="headerlink" title="将本地文件部署到 GitHub"></a>将本地文件部署到 GitHub</h1><h2 id="修改-Hexo-中的-config-yml-文件"><a href="#修改-Hexo-中的-config-yml-文件" class="headerlink" title="修改 Hexo 中的 _config.yml 文件"></a>修改 Hexo 中的 _config.yml 文件</h2><p>在 Hexo 文件夹下找到 _config.yml 文件,如下图所示：</p>
<img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/bloghexo6.png" alt="bloghexo6.png" title="">
<p>找到其中的 deploy 标签，改成下图所示形式，并保存。<strong>注意：冒号后面要加上一个空格，否则会报错。</strong><br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/bloghexo7.png" alt="bloghexo7.png" title=""></p>
<h2 id="将其-deploy-到仓库中"><a href="#将其-deploy-到仓库中" class="headerlink" title="将其 deploy 到仓库中"></a>将其 deploy 到仓库中</h2><p>打开 Git Shell 进入创建的文件夹，依次输入以下命令：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo <span class="keyword">generate</span></div><div class="line">hexo deploy</div></pre></td></tr></table></figure></p>
<p>如果出现下图错误，不要着急：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/bloghexo8.png" alt="bloghexo8.png" title=""><br>将deploy 的 type 改成 git，然后再在 Git Shell 中运行以下命令:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></div></pre></td></tr></table></figure></p>
<p>再重新来一遍：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo <span class="keyword">generate</span></div><div class="line">hexo deploy</div></pre></td></tr></table></figure></p>
<p>出现以下提示则表示正确：<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/bloghexo9.jpg" alt="bloghexo9.jpg" title=""></p>
<p>恭喜，到这一步，个人博客就已经部署到 GitHub 上了，你可以到你的<a href="http://www.github.com" target="_blank" rel="external">GitHub</a>仓库查看是否已经更新。此时,通过 your_user_name.github.io（即你那个仓库的名称，形如：”你的 GitHub 用户名”.github.io）,就可以看到你的个人博客了。</p>
<p>同时需要将<code>_config.yml</code>中的<code>url</code>改为<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">url:</span> <span class="string">http:</span><span class="comment">//your_user_name.github.io</span></div></pre></td></tr></table></figure></p>
<p>以便后面的评论和Sitemap的设置。</p>
<p>提示：上述搭建步骤大量参考了<a href="http://yangruihan.com/" target="_blank" rel="external">yangruihan</a>的博客，如果你对搭建过程还有疑问，可以查看他的原创博文：<a href="http://yangruihan.com/2015/03/22/Windows%E4%B8%8B%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%20GitHub%20Pages%20+%20Hexo%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">Windows下一步步搭建自己的独立博客——使用 GitHub Pages + Hexo 基础教程（一）</a>。</p>
<h1 id="发表博文"><a href="#发表博文" class="headerlink" title="发表博文"></a>发表博文</h1><p>辛苦了这么久，终于回到我们搭建博客最初的目标–写作，现在来看看怎么写博文并发表吧</p>
<h2 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h2><p>我们可以使用命令新建一篇博文,使用 Git Shell 进入 Hexo 文件夹，输入以下命令：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">new</span> <span class="string">"文章题目"</span></div></pre></td></tr></table></figure>
<p>命令执行完后，就会发现在 Hexo\source_posts 目录中多了一个文件博文名.md，这就是我们刚才新建的博文。</p>
<p>此外，我们也可以直接进入 Hexo\source_posts 目录中，右键新建一个文本文档，将名字改为博文名.md,这样也新建了一篇博文。<br>上面新建的博文是显示在单个文章界面，这里新建的页面是作为单个页面显示的，比如下图的分类、标签、归档和关于我，你点击后都是显示为单个页面。<br><img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogwrite1.png" alt="blogwrite1.png" title=""><br>你只需要记住新建博文是用上面的方法，新建页面是用这里的方法就行了，这里也采用命令新建页面：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">new</span> page <span class="string">"页面名称"</span></div></pre></td></tr></table></figure></p>
<p>命令执行完后，就会发现在在 Hexo\source 目录中多了一个文件夹，里面还有一个index.md,这就代表我们新建了一个页面。</p>
<h2 id="写博文"><a href="#写博文" class="headerlink" title="写博文"></a>写博文</h2><p>用文本编辑器打开上面新建的博文，如下图所示：</p>
<img src="/2016/08/23/利用GitHub-Pages和Hexo快速搭建个人博客/blogwrite2.png" alt="blogwrite2.png" title="">
<p>新建的页面略有不同，没有tags和categories标签。</p>
<p>三个”-“后面就是博文的正文内容，接下来就是正儿八经地撰写博文了。</p>
<p>因为我们的博文都是用<a href="http://baike.baidu.com/link?url=IbmQI2KgUUPKG7au6ae9bYTbSZl2ctDyPmHF2RZh2j4tPMKYjjyqERYyqCMHp5rdE5G-x9y7BLyNvBXMpi9tsK" target="_blank" rel="external">Markdown</a>语言写的，所以首先，你需要一个好用的Markdown编辑器。其实好用的Markdown编辑器一大堆，这里就给大家推荐两个，如果你用的不习惯也可以换其它的。</p>
<ul>
<li><p>本地编辑器：<a href="http://pad.haroopress.com/user.html" target="_blank" rel="external">Haroopad</a>,非常小众的一款Markdown编辑器，左边编辑右边实时预览效果，非常轻便;</p>
</li>
<li><p>在线编辑器：<a href="http://mahua.jser.me/" target="_blank" rel="external">MaHua</a>,也是比较小众的一款Markdown编辑器，但效果确实很棒，我的这篇博文就是用MaHua写的。</p>
</li>
</ul>
<p>现在你可以打开新建的博文了，然而还不造怎么下手对吧。其实很简单，除了特殊格式，其它的你就当做在word里面写文章就行了，具体请看这里的Markdown教程：<a href="http://www.jianshu.com/p/1e402922ee32/#" target="_blank" rel="external">Markdown——入门指南</a>。</p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在站点配置文件_config.yml中修改post_asset_folder：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">post_asset_folder:</span><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>然后执行下面命令重新生成<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo <span class="keyword">generate</span></div><div class="line">hexo deploy</div></pre></td></tr></table></figure></p>
<p>当创建新的页面<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">new</span> <span class="string">"page"</span></div></pre></td></tr></table></figure></p>
<p>时,可以发现在/source/_posts/文件夹中存在一个同名的资源文件夹,将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
<h3 id="相对路径引用的标签插件"><a href="#相对路径引用的标签插件" class="headerlink" title="相对路径引用的标签插件"></a>相对路径引用的标签插件</h3><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。<br><figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">asset_path</span> slug %&#125;</span><span class="xml"></span></div><div class="line"><span class="template-tag">&#123;% <span class="name">asset_img</span> slug [title] %&#125;</span><span class="xml"></span></div><div class="line"><span class="template-tag">&#123;% <span class="name">asset_link</span> slug [title] %&#125;</span><span class="xml"></span></div></pre></td></tr></table></figure></p>
<p>比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法<code>![](/example.jpg)</code>，它将<strong>不会</strong>出现在首页上。（但是它会在文章中按你期待的方式工作）<br>正确的引用图片方式是使用下列的标签插件而不是 markdown ：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="symbol">%</span> asset_img <span class="built_in">example</span>.jpg This <span class="built_in">is</span> an <span class="built_in">example</span> <span class="built_in">image</span> <span class="symbol">%</span>&#125;</div></pre></td></tr></table></figure></p>
<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>
<h2 id="发博文"><a href="#发博文" class="headerlink" title="发博文"></a>发博文</h2><p>呼啦啦，博文写好了，你得发表出去别人才看得到呀。依然在 Git Shell 中进入 Hexo 文件夹，执行下面几条命令，将博客部署到 GitHub 上：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo <span class="keyword">generate</span></div><div class="line"><span class="variable">#(若要本地预览就先执行 hexo server)</span></div><div class="line">hexo deploy</div></pre></td></tr></table></figure>
<p>快捷命令:<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo g == hexo <span class="keyword">generate</span></div><div class="line">hexo d == hexo deploy</div><div class="line">hexo s == hexo server</div><div class="line">hexo n == hexo <span class="keyword">new</span></div></pre></td></tr></table></figure></p>
<p> 还能组合使用，如：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">hexo d -g</span></div></pre></td></tr></table></figure></p>
<p>刷新你的个人博客，就可以看到新鲜出炉的博文了，赶紧邀请小伙伴们来欣赏吧。</p>
<p>话外音:其实到这里，你已经学会了怎么搭建并发表博客，所以最初的目标已经实现，可以happy地写博客去啦。后面是我自己的选修课，如果你也愿意像我一样折腾，就继续往下看吧O(∩_∩)O。</p>
<h1 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h1><h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>我们刚才使用Hexo生成的博客使用的是Hexo的默认主题：<a href="https://hexo.io/hexo-theme-landscape/" target="_blank" rel="external">Landscape</a>。怎么说呢，这个主题猛地一看还行，仔细一看还不如猛地一看，所以我决定另寻归宿。</p>
<p>然后，我来到了这里：<a href="https://github.com/hexojs/wiki/Themes" target="_blank" rel="external">Themes·Hexo</a>,瞬间有了一种村姑进城的感觉。我是一个一个地看，看得我眼花缭乱也没一个抉择，最后综合网友的评价，选择了这个主题：<a href="http://notes.iissnan.com/" target="_blank" rel="external">NexT</a>。</p>
<ul>
<li><p>简洁大方，比较符合我的品位；</p>
</li>
<li><p>作者<a href="http://notes.iissnan.com/" target="_blank" rel="external">iissnan</a>很勤快，持续更新主题，作者博客的样式就是他正在开发而未上线的NexT主题新样式。</p>
</li>
</ul>
<p>当然，每个人的品位都不一样，你也可以选择其它的主题，当然也欢迎你选择NexT主题，这样就能继续一起愉快地折腾啦。</p>
<h2 id="安装NexT主题-1"><a href="#安装NexT主题-1" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h2><p>Hexo 有两份主要的配置文件（_config.yml），一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>，后者称为 <strong>主题配置文件</strong>。</p>
<h2 id="下载-NexT-主题"><a href="#下载-NexT-主题" class="headerlink" title="下载 NexT 主题"></a>下载 NexT 主题</h2><p>使用 Git Shell 进入 Hexo 文件夹，输入以下两条命令：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cd</span> Hexo</div><div class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></div></pre></td></tr></table></figure></p>
<h2 id="启用NexT主题"><a href="#启用NexT主题" class="headerlink" title="启用NexT主题"></a>启用NexT主题</h2><p>下载完成后，打开 站点配置文件，找到 theme 字段，并将其值更改为 next。</p>
<h2 id="验证主题是否启用"><a href="#验证主题是否启用" class="headerlink" title="验证主题是否启用"></a>验证主题是否启用</h2><p>执行上面发博文的命令，刷新你的个人博客，就能看到你设置的主题是否启用。</p>
<h1 id="设置NexT主题和第三方服务"><a href="#设置NexT主题和第三方服务" class="headerlink" title="设置NexT主题和第三方服务"></a>设置NexT主题和第三方服务</h1><p>安装完NexT之后，还是发现不够漂亮对不对，所以下面我们来慢慢地润色你的个人博客。</p>
<h2 id="支持Latex"><a href="#支持Latex" class="headerlink" title="支持Latex"></a>支持Latex</h2><p>经过一番google之后，发现有位高手已经写好了一个自动部署MathJax的hexo插件<br><a href="http://catx.me/2014/03/09/hexo-mathjax-plugin/" target="_blank" rel="external">Hexo MathJax插件</a><br>安装方式也很简单，在你的博客文件夹下执行——<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-<span class="built_in">math</span> <span class="comment">--save</span></div><div class="line">hexo <span class="built_in">math</span> install</div></pre></td></tr></table></figure></p>
<p>然后在新建的博文中写上一个麦克斯韦方程组查看LaTeX效果——<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="formula">$$</span></div><div class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;eqnarray&#125;</span></span></div><div class="line"><span class="tag">\<span class="name">nabla</span></span><span class="tag">\<span class="name">cdot</span></span><span class="tag">\<span class="name">vec</span><span class="string">&#123;E&#125;</span></span> &amp;=&amp; <span class="tag">\<span class="name">frac</span><span class="string">&#123;\rho&#125;</span><span class="string">&#123;\epsilon_0&#125;</span></span> <span class="tag">\<span class="name">\</span></span></div><div class="line"><span class="tag">\<span class="name">nabla</span></span><span class="tag">\<span class="name">cdot</span></span><span class="tag">\<span class="name">vec</span><span class="string">&#123;B&#125;</span></span> &amp;=&amp; 0 <span class="tag">\<span class="name">\</span></span></div><div class="line"><span class="tag">\<span class="name">nabla</span></span><span class="tag">\<span class="name">times</span></span><span class="tag">\<span class="name">vec</span><span class="string">&#123;E&#125;</span></span> &amp;=&amp; -<span class="tag">\<span class="name">frac</span><span class="string">&#123;\partial B&#125;</span><span class="string">&#123;\partial t&#125;</span></span> <span class="tag">\<span class="name">\</span></span></div><div class="line"><span class="tag">\<span class="name">nabla</span></span><span class="tag">\<span class="name">times</span></span><span class="tag">\<span class="name">vec</span><span class="string">&#123;B&#125;</span></span> &amp;=&amp; <span class="tag">\<span class="name">mu</span></span>_0<span class="tag">\<span class="name">left</span></span>(<span class="tag">\<span class="name">vec</span><span class="string">&#123;J&#125;</span></span>+<span class="tag">\<span class="name">epsilon</span></span>_0<span class="tag">\<span class="name">frac</span><span class="string">&#123;\partial E&#125;</span><span class="string">&#123;\partial t&#125;</span></span> <span class="tag">\<span class="name">right</span></span>)</div><div class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;eqnarray&#125;</span></span></div><div class="line">$$</div></pre></td></tr></table></figure></p>
<p>这时如果你会发现出了一些问题，原因是hexo先用marked.js渲染，然后再交给MathJax渲染。在marked.js渲染的时候下划线<code>_</code>是被escape掉并且换成了<code>&lt;em&gt;</code>标签，即斜体字，另外LaTeX中的<code>\\</code>也会被转义成一个<code>\</code>，这样会导致MathJax渲染时不认为它是一个换行符了。</p>
<p>因此我提供一个修改marked.js源码的方式来避开这些问题</p>
<ul>
<li>针对下划线的问题，我决定取消<code>_</code>作为斜体转义，因为marked.js中<code>*</code>也是斜体的意思，所以取消掉<code>_</code>的转义并不影响我们使用markdown，只要我们习惯用<code>*</code>作为斜体字标记就行了。 </li>
<li>针对marked.js与Mathjax对于个别字符二次转义的问题，我们只要不让marked.js去转义<code>\\,\{,\}</code>在MathJax中有特殊用途的字符就行了。 </li>
</ul>
<p>具体修改方式，用编辑器打开marked.js（在./node_modules/marked/lib/中）<br>Step 1:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/,</div></pre></td></tr></table></figure></p>
<p>替换成<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/,</div></pre></td></tr></table></figure></p>
<p>这一步是在原基础上取消了对\\,\{,\}的转义(escape)</p>
<p>Step 2:<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">em: /^<span class="symbol">\b</span>_((?:[^_]|__)+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</div></pre></td></tr></table></figure></p>
<p>替换成<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">em:/^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</div></pre></td></tr></table></figure></p>
<p>这样一来MathJax就能与marked.js共存了。重启一下hexo看一下吧!</p>
<h2 id="选择样式"><a href="#选择样式" class="headerlink" title="选择样式"></a>选择样式</h2><p>NexT默认的样式其实也比较丑，幸好作者提供了一款十分漂亮的样式:Mist。启用 Mist 很简单，仅需在 主题配置文件 中将 #scheme: Mist 前面的 # 注释去掉即可。</p>
<h2 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h2><p>菜单配置在 主题配置文件 的 menu，下面是菜单配置示例：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">menu</span>:</div><div class="line">  #home: /</div><div class="line">  archive<span class="variable">s:</span> /archives</div><div class="line">  abou<span class="variable">t:</span> /about</div><div class="line">  categorie<span class="variable">s:</span> /categories</div><div class="line">  <span class="keyword">tag</span><span class="variable">s:</span> /<span class="keyword">tags</span></div><div class="line">  #commonwea<span class="variable">l:</span> /<span class="number">404</span>.html</div></pre></td></tr></table></figure></p>
<p>其它的很多在<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT官方文档</a>里面已经讲的很清楚了，我就不在这里重复造轮子了，下面我只讲下NexT官方文档里没有提到过的地方。</p>
<ul>
<li><p>sitemap : <a href="http://baike.baidu.com/link?url=Hvuhn8v3mmoNI6iVHm_NrZilTuHxsvLfpZJWZQwlZ4mjAAw_Bd4M_M8AnlPMj_L1Jv2tjFCdTdsV32iuwo_Qwq" target="_blank" rel="external">sitemap</a>是一个包含网站中的所有网址以及每个网址的其他元数据的文件，以便搜索引擎可以更加智能地抓取网站。我们先来看看Hexo支持哪些插件：<a href="https://hexo.io/plugins/" target="_blank" rel="external">Plugins | Hexo</a>,可以看到有<a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="external">hexo-generator-sitemap</a>这个插件，在README.md文件中已经讲述了安装方法，只是要注意sitemap这个标签要加在主题配置文件中。再次部署你的博客，看到你的GitHub仓库中多了sitemap.xml文件，那么sitemap就部署成功了。</p>
</li>
<li><p>多说评论框 : 多说评论框默认的样式确实比较丑，请看这里美哭的效果：<a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="external">多说自定义CSS 让你的多说评论动感起来</a>；另外，在设置<strong>评论显示样式</strong>时，可以设置为<strong>嵌套显示</strong>，美观了不少。</p>
</li>
<li><p>生成favicon : 所谓<a href="http://baike.baidu.com/link?url=shMog2srG2OphNuZNmQ8LseNMOWIrNwyppJ1YP0TwDp3VUYnzBjiPqb41Cqjr-84wwhZnG55cN_-Cp40ybKjNa" target="_blank" rel="external">favicon</a>,即Favorites Icon,顾名思义，就是收藏夹图标，也是地址栏左边的图标。如果没有设置favicon,地址栏左边就是一片空白，把favicon成你喜欢的图片，打造个性化标志，博客瞬间生动了不少。这里推荐一个网站，可以在线生成favicon,简单实用：<a href="http://www.atool.org/ico.php" target="_blank" rel="external">在线透明favicon ico图标文件制作 - aTool在线工具</a>。生成favcion后，再按照NexT官方文档的方法，就能设置favicon了。</p>
<h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>NexT 支持 <a href="http://duoshuo.com/" target="_blank" rel="external">多说</a> 和 <a href="https://disqus.com/" target="_blank" rel="external">DISQUS</a> 评论系统。 当同时设置了多说和DISQUS时，优先选择多说。 NexT内置了一套多说的样式。<br><strong>如需取消某个 页面/文章 的评论，在 md 文件的 <a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="external">front-matter</a> 中增加<code>comments: false</code> </strong></p>
<h3 id="多说"><a href="#多说" class="headerlink" title="多说"></a>多说</h3><p>使用多说前需要先在<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a> 创建一个站点。具体步骤如下：</p>
</li>
</ul>
<ol>
<li>登录后在首页选择 “我要安装”。</li>
<li><p>创建站点，填写表单。<strong>多说域名</strong>这一栏填写的即是你的 <code>duoshuo_shortname</code>，如图：</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">asset_img</span> duoshuo-create-site.png  %&#125;</span><span class="xml"></span></div></pre></td></tr></table></figure>
</li>
<li><p>创建站点完成后在<strong>站点配置文件</strong>中新增<code>duoshuo_shortname</code>字段，值设置成上一步中的值。</p>
</li>
</ol>
<p>同时可以在多说的控制台界面中选择多种样式与属性选项。如嵌套回复、多说分享等。</p>
<h4 id="多说分享"><a href="#多说分享" class="headerlink" title="多说分享"></a>多说分享</h4><p>多说分享必须与多说评论同时使用</p>
<p>编辑 <strong>站点配置文件</strong>， 添加字段<code>duoshuo_share</code>， 值为<code>true</code>。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 多说分享服务</span></div><div class="line"><span class="attr">duoshuo_share:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h3 id="DISUQS"><a href="#DISUQS" class="headerlink" title="DISUQS"></a>DISUQS</h3><p>编辑<strong>站点配置文件</strong>， 添加 <code>disqus_shortname</code>字段，设置如下：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">disqus_shortname:</span> your-disqus-shortname</div></pre></td></tr></table></figure></p>
<h2 id="搜索服务-Local-Search"><a href="#搜索服务-Local-Search" class="headerlink" title="搜索服务(Local Search)"></a>搜索服务(Local Search)</h2><p>添加百度/谷歌/本地 自定义站点内容搜索</p>
<ol>
<li><p>安装 hexo-generator-search，在站点的根目录下执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm <span class="keyword">install</span> hexo-generator-<span class="keyword">search</span> <span class="comment">--save</span></div></pre></td></tr></table></figure>
</li>
<li><p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">	path: search.<span class="keyword">xml</span></div><div class="line">	<span class="title">field</span>: post</div></pre></td></tr></table></figure>
</li>
</ol>
<p>第三方的服务可以参考:<br><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="external">NexT官方文档</a><br><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo官方文档</a></p>
]]></content>
    </entry>
    
  
  
</search>
